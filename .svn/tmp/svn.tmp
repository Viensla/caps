/* colors */
var cblue = 0x67AAC1;
var cyellow = 0xF7D443;
var cgreen = 0x78AD60;
var cred = 0xC1676A;

var ptpgrey = 0x595556;
var ptpyellow = 0xfedc2a;



var container, scene, renderer, light, ball, plane, bottle, bottlecaps, axes, initEventHandling, initScene;
var WIDTH, HEIGHT, planeWIDTH, planeHEIGHT;

var elements = [], playedCaps = null, mouse_position = new THREE.Vector3, block_offset = new THREE.Vector3, _i, _v3 = new THREE.Vector3, intersect_plane, lookatobj, pilone, mouse,
    mouse3D = new THREE.Vector3;

var _nullVector = new THREE.Vector3(0,0,0), DCMP  = new THREE.Vector3(0,0,0);
var _natVector = new THREE.Vector3(1,1,1);

var onRenderFcts= [];

var lastTimeMsec= null;

var capsYpos = 110;

var movingCaps = null;

var clock = new THREE.Clock(), dir, distance;

var holdingDown = false;



Physijs.scripts.worker = '/js/physijs/physijs_worker.js';
Physijs.scripts.ammo = 'ammo.js';

container = document.querySelector('.viewport');

WIDTH = window.innerWidth;
HEIGHT = window.innerHeight;

var playerDistance = 100;

var globalDirection = 1;

var capModelscale = 1.6;

var geo_caps, bottle_geo, bottle_mat;

var $plpart, $vlpart;

var texture;

var composer;



var caps_material;
var mat_caps_foster;
var mat_caps_chimey;
var mat_caps_ptp;
function loadBottleTools(){
    var loader = new THREE.JSONLoader();
    loader.load( 'model/chimey/chimey.json', function ( cap_geometry, cap_materials ) {

        loader.load( 'model/bottle/bottle_chimey.json', function ( bottle_geometry, bottle_materials ) {

            bottle_geo = bottle_geometry;


            var bottle_material = bottle_materials[ 0 ];
            bottle_material.side = 2;
            bottle_material.map.anisotropy=0;
            bottle_material.shininess = 0;
            bottle_material.shading = 0;
            bottle_material.reflectivity = 0;
            bottle_material.ambient.setHex(0xffffff);
            bottle_material.color.setHex(0xffffff);

            bottle_mat = new THREE.MeshFaceMaterial( bottle_materials );

            geo_caps = cap_geometry;

            // CHIMEY CAPS ----------------------------------------------


            var copychimey  = [];
            copychimey[0] = cap_materials[0].clone();
            copychimey[1] = cap_materials[0].clone();
            copychimey[0].side = 2;
            copychimey[1].side = 2;
            copychimey[1].map = 0;

            mat_caps_chimey = new THREE.MeshFaceMaterial(copychimey);
            mat_caps_chimey.materials[1].color =  new THREE.Color(0x2f74e9);

            // FOSTER CAPS ----------------------------------------------

            var copyfoster  =[];
            copyfoster[0] = cap_materials[1].clone();
            copyfoster[1] = cap_materials[0].clone();
            copyfoster[0].side = 2;
            copyfoster[1].side = 2;
            copyfoster[1].map = 0;

            mat_caps_foster = new THREE.MeshFaceMaterial(copyfoster);
            mat_caps_foster.materials[1].color =  new THREE.Color(0x0b1f6f);


            // PTP CAPS ----------------------------------------------

            var copyptp  =[];
            copyptp[0] = cap_materials[2].clone();
            copyptp[1] = cap_materials[2].clone();
            copyptp[0].side = 2;
            copyptp[1].side = 2;
            copyptp[1].map = 0;

            mat_caps_ptp = new THREE.MeshFaceMaterial(copyptp);
            mat_caps_ptp.materials[1].color =  new THREE.Color(ptpyellow);


            caps_material = {
                'chimey':mat_caps_chimey,
                'foster':mat_caps_foster,
                'ptp':mat_caps_ptp
            }
            initScene();
        });
    });
}






initScene = function() {


    scene = new Physijs.Scene();

    scene.setGravity(new THREE.Vector3( 0, -80, 0 ));

    scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

    renderer = new THREE.WebGLRenderer({
        antialias: true
    });

//    renderer.setSize(WIDTH, HEIGHT-100); //16:9
    renderer.setSize(WIDTH, HEIGHT);
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFShadowMap;
    renderer.shadowMapAutoUpdate = true;

    renderer.gammaInput = true;
    renderer.gammaOutput = true;

    renderer.setClearColor( scene.fog.color, 1 );
    container.appendChild(renderer.domElement);

    create_camera();

    create_lights();

    create_table();

    Viensla.initialize();
    Player.initialize();

    lookatobj = Viensla.bottle;

    scene.simulate();

    initEventHandling();

    _init_composer();


    render();

//    scene.addEventListener('update', function() {
//
//
//
//    });
};



function _init_composer(){

    composer = new THREE.EffectComposer( renderer );
    composer.addPass( new THREE.RenderPass( scene, camera ) );
    var hblur = new THREE.ShaderPass( THREE.HorizontalBlurShader );
    composer.addPass( hblur );
    var vblur = new THREE.ShaderPass( THREE.VerticalBlurShader );
// set this shader pass to render to screen so we can see the effects
    vblur.renderToScreen = true;
    composer.addPass( vblur );
}



function render() {

    if(Party.isPlaying){
        if( (Viensla.bottlecaps.position.y <= Viensla.bottle.position.y
                || Viensla.bottlecaps.position.y > Viensla.bottle.position.y + 35
                || Viensla.bottlecaps.position.x > Viensla.bottle.position.x + 7
                || Viensla.bottlecaps.position.x < Viensla.bottle.position.x - 7
                || Viensla.bottlecaps.position.z > Viensla.bottle.position.z + 7
                || Viensla.bottlecaps.position.z < Viensla.bottle.position.z - 7)
                && Viensla.bottlecaps.collided){

            console.log(Viensla.bottlecaps.position, Viensla.bottle.position);
            Viensla.bottlecaps.collided = false;
            Party.plcaps();
        }


        if( (Player.bottlecaps.position.y <= Player.bottle.position.y
            || Player.bottlecaps.position.y > Player.bottle.position.y + 35
            || Player.bottlecaps.position.x > Player.bottle.position.x + 7
            || Player.bottlecaps.position.x < Player.bottle.position.x - 7
            || Player.bottlecaps.position.z > Player.bottle.position.z + 7
            || Player.bottlecaps.position.z < Player.bottle.position.z - 7)
            && Player.bottlecaps.collided){
            console.log(Player.bottlecaps.position, Player.bottle.position);
            Player.bottlecaps.collided = false;
            Party.vlcaps();
        }
    }


    if(playedCaps && Player.isPlaying){
        playedCaps.position.copy(DCMP);
    }

    if(holdingDown){
        setPower();
    }

    scene.simulate(undefined, 2);


    camera.lookAt(lookat);

    var time = Date.now() * 0.0005;

    drunk_effect(time);

    renderer.render(scene, camera);

    if(Player.drunked > 10){
        composer.render();
    }

    if( Math.sin( time*2 ) > 0.5){
        pointlightbar.animeLight();
    }

    if(holdingDown){
        calculate_traj();
    }


    requestAnimationFrame(render);



}

function anime_bar_light(){

}

var subdatenow = Date.now();
function drunk_effect(time){


    if(Player.outline.position){

        Player.outline.position.x = -camera.position.x / (520 + Math.abs(camera.position.x)*5 );
        Player.outline.position.z = Math.min(Math.abs(camera.position.x/1500) - 0.13, 0) ;

//        Player.outline.position.x = -camera.position.x / ((camera.position.z - Player.bottle.position.z)*100) ;
        Player.outline.mass = 0;
    }

    camera.initialpos.x += Math.sin( time*2 ) * Player.drunked/70;
    camera.initialpos.y += Math.cos( time*2 ) * Player.drunked/70;
    camera.initialpos.z += Math.sin( time*2 ) * Player.drunked/70;

//    console.log(Math.sin( time*2 ) * Player.drunked/30);

    if(Player.drunked > 10){
        camera.position.x += ( Math.sin( time*10 )*2 - camera.position.x) * (0.5*3) + camera.initialpos.x;
        camera.position.y += ( Math.cos( time*10 )*2 - camera.position.y) * (0.5*3) + camera.initialpos.y+60;

        if(Math.random() > 0.99){
            aspirinerm();
        }
    }else{
        camera.position.x += (mouse.x * 20 - camera.position.x) * (0.3*3) + camera.initialpos.x;
        camera.position.y += (mouse.y * 10 - camera.position.y) * (0.5*3) + camera.initialpos.y+80;
    }

}




$(document).ready(function(){
    $plpart = $('.pl-part');
    $vlpart = $('.vl-part');



    loadBottleTools();

    window.addEventListener( 'resize', onWindowResize, false );

    $('.beers-selector .beer').click(function(){
        var $th = $(this);

       $('.beer.selected').removeClass('selected');
       $(this).addClass('selected');
        $plpart.removeClass('chimey foster ptp');

        if($th.hasClass('chimey')){
            Player.capmat = caps_material.chimey.clone();
            $plpart.addClass('chimey');

        }else if($th.hasClass('foster')){
            Player.capmat = caps_material.foster.clone();
            $plpart.addClass('foster');


        }else if($th.hasClass('ptp')){
            Player.capmat = caps_material.ptp.clone();
            $plpart.addClass('ptp');

        }
        Player.bottle.material.color = Player.capmat.materials[1].color;

    });


    $('#party').click(function(){
        Party.create();
    });

    $('#mute').click(function(){
        Sounds.mute = !Sounds.mute;
    });

    for(var i =0; i < Party.capsPerTurn; i++){
        $('.capsstock').append('<span class="animated zoomIn"></span>');
    }

    $('#aspirine').click(function(){
       Player.drunked -= 10;
       camera.initialpos.x = 0;
    });


    $plpart.find('.capsstock span').click(function(){

        if(!Viensla.isPlaying){
            $(this).removeClass().addClass('animated zoomOut');
            Party.plplay();
        }
    });

});



function onWindowResize( event ) {

    renderer.setSize( window.innerWidth, window.innerHeight );

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

}
;var playerCamera;
var vlCamera;
var camera;
var vlCamPos = new THREE.Vector3( 0, 210, -170 );

var lookat = new THREE.Vector3(0,50,-100);
var playerCamPos = new THREE.Vector3( 0, 160, 165 );


var VIEW_ANGLE = 75,
    ASPECT = WIDTH / HEIGHT,
    NEAR = 0.1,
    FAR = 10000;

function create_camera(){

    playerCamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    playerCamera.position.set(playerCamPos.x, playerCamPos.y, playerCamPos.z);
    playerCamera.lookAt(scene);
    scene.add(playerCamera);


    vlCamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    vlCamera.position.set(vlCamPos.x, vlCamPos.y, vlCamPos.z);
    vlCamera.lookAt(scene);
    scene.add(vlCamera);




    camera = playerCamera;
    camera.initialpos = playerCamPos;

//    camera.focalLength = 25;
//    camera.frameSize = 32;
//    camera.setLens(camera.focalLength, camera.frameSize);

    mouse = {x : 0, y : 0};

    document.addEventListener('mousemove', function(event){
        mouse.x	= (event.clientX / window.innerWidth ) - 0.5;
        mouse.y	= (event.clientY / window.innerHeight) - 0.5;

//        if(Player.drunked < 11){
////            camera.position.x += (mouse.x * 20 - camera.position.x) * (0.5*3) + camera.initialpos.x;
////            camera.position.y += (mouse.y * 10 - camera.position.y) * (0.5*3) + camera.initialpos.y-10;
//        }
//        camera.lookAt(lookatobj);
    }, false);
}

function change_camera(){
    if(camera == playerCamera){
        camera = vlCamera;
        camera.initialpos = vlCamPos;
        lookatobj = Player.bottle;
        globalDirection = -1;

    }else{
        camera = playerCamera;
        camera.initialpos = playerCamPos;
        lookatobj = Viensla.bottle;
        globalDirection = 1;


    }
};


capCollision = function ( collided, linearVelocity, angularVelocity, other ){

    var capPlayed = this;
    capPlayed.collisions++;

    if(capPlayed.floating) return;


    var collision = collided.name;


    switch(collision){
        case 'level':
            if(!Sounds.mute) Sounds.simpletap2.play();
            break;
        case 'tapis':
            if(!Sounds.mute) Sounds.simpletap1.play();
            break;
        case 'floor':
            if(!Sounds.mute) Sounds.simpletap3.play();
            break;
        case 'vlCap':

            if(capPlayed.name == 'player'){
                collided.collided = true;
            }

            if(!Sounds.mute) Sounds.capcap.play();

            break;
        case 'plCap':

            if(capPlayed.name == 'viensla'){
                collided.collided = true;
            }

            if(!Sounds.mute) Sounds.pschit1.play();

            break;
        case 'vlBottle':
            if(!Sounds.mute) Sounds.clink.play();
            break;
        case 'plBottle':
            if(!Sounds.mute) Sounds.pschit1.play();
            break;
        case '':
            console.log('Unamed hit !');
            break;
    }



    if(collision == 'vlCap'){
        collided.__dirtyPosition = true;
    }



};




function create_caps(who){
    var randomCaps = Math.random() > 0.8;
    var mass = randomCaps ? 3 : 2;

    if(typeof who == 'undefined'){
        who = 'pl';
    }


    var cap_mat;
    if(who == 'pl'){
        cap_mat = Player.capmat.clone();
    }else{
        cap_mat = Viensla.capmat.clone();
    }

    cap_mat.side = 2;


    ball = new Physijs.CylinderMesh(geo_caps, cap_mat, mass, {friction : 0, restitution : 0.8});

    ball.scale.set(capModelscale,capModelscale,capModelscale);


    ball.collisions = 0;
    ball.addEventListener( 'collision', capCollision );

    var sub = new Physijs.CylinderMesh(
        new THREE.CylinderGeometry(1.5, 1.5, 0, 32, 32 ),
        new THREE.MeshLambertMaterial({
            color: ball.material.materials[1].color,
            transparent : true,
            opacity:1
        })
        ,0);
    sub.position.x = 0;
    sub.position.y = 0.3;
    sub.position.z = 0;

    ball.add(sub);


    ball.position.y = 50;
    ball.position.x = 0;
    ball.position.z = playerDistance * globalDirection;
    ball.castShadow = true;
    ball.receiveShadow = true;

    scene.add(ball);
    elements.push(ball);

    playedCaps = ball;

    playedCaps.floating = true;

    playedCaps.name = who == 'vl' ?  'viensla' : 'player';


    if(elements.length > 10){
        var last = elements[0];
        scene.remove(last);
        elements.splice(0, 1);
    }

    if(!Sounds.mute) Sounds.pschit1.play();
}





var power = 0,
    speedbar = 2,
    powerDir = speedbar,
    strengh = 6,
    playerstrengh = 5;


function setPower(){
    power += powerDir;

    if(power > 100){
        powerDir = -speedbar;
    }

    if(power < 0){
        powerDir = +speedbar;
    }

    $('.powerbar .bar').height(power+'%');
}






initEventHandling = (function() {
    var projector, ray, intersection,
        handleMouseDown, handleMouseMove, handleMouseUp,
        launchVector = new THREE.Vector3,
        _vector = new THREE.Vector3,
        _angVector = new THREE.Vector3;


    handleMouseDown = function( evt ) {

        if(!playedCaps) return;

        holdingDown = true;

        launchVector.set(1,20, -100);

        power = 0;
        $('.powerbar').fadeIn();

    };

    handleMouseMove = function( evt ) {
        var mouseX = evt.clientX,
            mouseY = evt.clientY;


        $('.powerbar').css({left:mouseX+50, top:mouseY-50});


        if(!playedCaps) return;
        mouse3D.set(
            ( mouseX / window.innerWidth ) * 2 - 1,
            - ( mouseY / window.innerHeight ) * 2 + 1.07 ,
            1 );

        mouse3D.unproject(camera);

        dir = mouse3D.sub( camera.position ).normalize();

        distance = - camera.position.z / dir.z;

        DCMP = camera.position.clone().add( dir.multiplyScalar(distance/2) );

        DCMP.z = playerDistance*globalDirection;
    };

    handleMouseUp = function( evt ) {

        if(!playedCaps) return;



        holdingDown = false;

        playedCaps.__dirtyPosition = true;
        playedCaps.floating = false;

        _vector.set( 1, 1, 1 );
        _angVector.set( Math.random()*10, Math.random()*10, Math.random()*20);
        playedCaps.setAngularFactor( _vector );

        playedCaps.setLinearFactor( _vector );
        launchVector.set(1,1, -power*playerstrengh*globalDirection);
        playedCaps.setLinearVelocity( launchVector );
        playedCaps.setAngularVelocity( _angVector );

        playedCaps.position.copy(DCMP);

        playedCaps = null;

        power = 0;

        $('.powerbar').fadeOut();

        Player.launched++;
        Player.totalLaunched++;

        if(Player.launched == Party.capsPerTurn){



            setTimeout(function(){
                console.log('viens la attack');
                Viensla.launched = 0;
                Player.isPlaying = false;
                Party.resetStocks();

                Party.vlplay();
                $('#turn-m p').text('Vienslà\'s turn!');
                turnm();

            }, 3000);

        }

    };

    return function() {
        renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
        renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
        renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
    };
})();

var sphere_traj;
var middlepos = new THREE.Vector3(0,150,0);
var endpos = new THREE.Vector3();

function calculate_traj(){



    var x = DCMP.x;
    var y = 20;
    var z = 0;

//    console.log(DCMP);

    z = - ( power*(power/100) + DCMP.y/2 );

    sphere_traj.position.set(x, y, z);

    endpos.set(x, y, z);

//    trajCap.calculate(DCMP, middlepos ,endpos)

//    trajLine.position.set(DCMP);

};var timeoutRobot;

var Party = {
    isPlaying : false,
    capsPerTurn : 1,
    lives : 100,
    create : function(){
        Viensla.score = Player.score = Viensla.launched = Player.launched = 0;
        Viensla.lives = Player.lives = Party.lives;

        Party.isPlaying = true;

        this.resetStocks();

        Viensla.isPlaying = false;
        Player.isPlaying = true;


        $vlpart.fadeIn(function(){
            Party.setLife();
        });
        $plpart.fadeIn();

        $('#start-screen').fadeOut();
        $('#black_filter').fadeOut();

        Player.generateCaps();


    },
    vlplay : function(){

        if(this.isPlaying){
            if(Viensla.launched < Party.capsPerTurn && !Player.isPlaying){

                $vlpart.find('.capsstock span').eq(Viensla.launched).removeClass().addClass('animated zoomOut');

                Viensla.isPlaying = true;
                Player.isPlaying = false;
                Viensla.launchCaps();
                Viensla.launched++;
                Viensla.totalLaunched++;

                if(Viensla.launched < Party.capsPerTurn){
                    timeoutRobot = setTimeout(function(){
                        Party.vlplay();
                    }, 3000);
                }else{

                    Player.isPlaying = true;
                    Player.launched = 0;
                    Viensla.isPlaying = false;
                    console.log('Viens la no more caps !');
                    this.resetStocks();
                    $('#turn-m p').text('Your turn!');
                    turnm();
                }



            }else{
                console.log('Viens la no more caps !');
            }
        }




    },
    plplay : function(){
        if(this.isPlaying){

            if(Player.launched < Party.capsPerTurn && !Viensla.isPlaying){
                globalDirection = 1;
                create_caps('pl');


                Player.isPlaying = true;
                Viensla.isPlaying = false;
            }
        }
    },

    vlcaps : function(){
        if(this.isPlaying){
            Viensla.isPlaying = false;
            Player.isPlaying = true;


            Viensla.score++;

            Player.drunked += 2;

            Player.lives -= Math.round((10 + 6 - Viensla.launched*2));

            capsm();

            if(Viensla.launched < Party.capsPerTurn-1){
                setTimeout(function(){
                    $('#turn-m p').text('Your turn!');
                    turnm();
                },1000);


                setTimeout(function(){
                    Party.resetStocks();
                }, 2000);
            }
            setTimeout(function(){
                Player.generateCaps();
            }, 2000);

            Party.setLife();

        }
    },


    plcaps : function(){
        if(this.isPlaying){
            Player.score++;
            Viensla.lives -= Math.round((10 + 6 - Player.launched*2));
            Player.isPlaying = false;
            Viensla.isPlaying = true;

            capsm();

            if(Player.launched < Party.capsPerTurn){
                setTimeout(function(){
                    $('#turn-m p').text('Vienslà\'s turn!');
                    turnm();
                },1000);

                setTimeout(function(){
                    Party.resetStocks();
                    Party.vlplay();
                }, 2000)
            }

            setTimeout(function(){
                Viensla.generateCaps();
            }, 2000);

            Party.setLife();
        }

    },

    resetStocks : function(){
        if(this.isPlaying){
            console.log('stock reseted');

            $('.capsstock span.zoomOut').removeClass('zoomOut').addClass('zoomIn');

            Viensla.launched = 0;

            Player.launched = 0;


        }

        if(Player.drunked > 11){
            Player.drunked -= 2;
        }
    },

    setLife : function(){
        if(this.isPlaying){
            var pctPlLife = Math.round(Player.lives / Party.lives * 100);
            var pctVlLife = Math.round(Viensla.lives / Party.lives * 100);

            $plpart.find('.life').height(pctPlLife+"%");
            $vlpart.find('.life').height(pctVlLife+"%");

            if(pctPlLife <= 0 || pctVlLife <= 0){
                Party.isPlaying = false;
                console.log('PARTY OVER');

                if(pctPlLife <= 0){
                    $('#winner-m p').text('Vienslà wins !')
                }else if(pctVlLife <= 0){
                    $('#winner-m p').text('You win !')
                }

                winnerm();

                $('#black_filter').fadeIn();
                $('#start-screen').fadeIn();
            }
        }
    }
}



var animend ='webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';
function capsm(){
    $('#caps-m').show().removeClass().addClass('animated tada').one(animend, function(){
        $(this).removeClass().addClass('animated zoomOut').one(animend, function(){
            $(this).hide()
        });
    });
    if(!Sounds.mute) Sounds.pschit2.play();
}

function turnm(){

    if($('#turn-m').hasClass('bounceOutRight') || $('#turn-m').hasClass('bounceInLeft') ) return;

    $('#turn-m').removeClass().addClass('animated bounceInLeft').show().one(animend, function(){
        $(this).removeClass().addClass('animated bounceOutRight').one(animend, function(){
            $(this).removeClass().hide();
        });
    });
    if(!Sounds.mute) Sounds.pschit2.play();
}


function winnerm(){
    $('#winner-m').removeClass().addClass('animated bounceInLeft').show().one(animend, function(){
        $(this).removeClass().addClass('animated bounceOutRight');
    });
    if(!Sounds.mute) Sounds.pschit2.play();
}


function aspirinerm(){
    if($('#aspirine').hasClass('bounceOutRight') || $('#aspirine').hasClass('bounceInLeft') ) return;

    $('#aspirine').removeClass().addClass('animated bounceInLeft').show().one(animend, function(){
        $(this).removeClass().addClass('animated bounceOutRight').one(animend, function(){
            $(this).removeClass().hide();
        });
    });
    if(!Sounds.mute) Sounds.pschit2.play();
};
planeWIDTH = 180;
planeHEIGHT = 800;


var tableSurfaceDim = [160, 5, 30];
var tablefootSurfaceDim = [150, 55, 2];
var level, _floor, _tapis, _tablefoot, _table, _wall;
function create_table(){

    //Set Level group
    level = new Physijs.BoxMesh(
        new THREE.BoxGeometry( 1, 1, 1 ),
        new THREE.MeshLambertMaterial({
                color: ptpgrey
        }),0
    );
    level.position.x = 0;
    level.position.y = 0;
    level.position.z = 0;
    level.castShadow = false;
    level.receiveShadow = true;
    level.name = 'level';



    //Add floor to level
    _floor = new Physijs.BoxMesh(
        new THREE.BoxGeometry(3000, 3000, 35),
        new THREE.MeshPhongMaterial({
            color: 0x3e3c3c
        }),0
    );
    _floor.rotation.x = Math.PI/2;
    _floor.position.x = 0;
    _floor.position.y = -1;
    _floor.position.z = 0;
    _floor.castShadow = true;
    _floor.receiveShadow = true;
    _floor.name = 'floor';

    level.add(_floor);


    //Add Wall to level
    var wall_texture = THREE.ImageUtils.loadTexture('images/fond_people.png');

    _wall = new Physijs.BoxMesh(
        new THREE.BoxGeometry(912, 235, 10),
        new THREE.MeshPhongMaterial({
            map:wall_texture,
            transparent:true,
            opacity:1
        }),
        0
    );
    _wall.position.x = 0;
    _wall.position.y = 130;
    _wall.position.z = -330;
    _wall.castShadow = true;
    _wall.receiveShadow = true;

    level.add(_wall);

     wall_texture = THREE.ImageUtils.loadTexture('images/fond_2_bar.png');
    _wall = new Physijs.BoxMesh(
        new THREE.BoxGeometry(1012, 285, 10),
        new THREE.MeshPhongMaterial({
            map:wall_texture,
            transparent:true,
            opacity:1
        }),
        0
    );
    _wall.position.x = 0;
    _wall.position.y = 130;
    _wall.position.z = -430;
    _wall.castShadow = true;
    _wall.receiveShadow = true;


    level.add(_wall);



    _tapis = new Physijs.BoxMesh(
        new THREE.BoxGeometry(planeWIDTH, planeHEIGHT, 35),
        new THREE.MeshPhongMaterial({
            color: ptpyellow
        }), 0
    );
    _tapis.rotation.x = Math.PI/2;
    _tapis.position.x = 0;
    _tapis.position.y = 0;
    _tapis.position.z = 0;
    _tapis.castShadow = false;
    _tapis.receiveShadow = true;
    _tapis.name = 'tapis';

    scene.add(_tapis);



    //Add table foots


    var _tablefoot_geometry = new THREE.BoxGeometry(tablefootSurfaceDim[0], tablefootSurfaceDim[1]+8, tablefootSurfaceDim[2]);

    _tablefoot = new Physijs.BoxMesh(
        _tablefoot_geometry,
        new THREE.MeshPhongMaterial({
            color: cblue
        })
    , 0);


    var _tablefoot_outlines = new Physijs.BoxMesh(
        _tablefoot_geometry,
        new THREE.MeshPhongMaterial({
            color: 0x000000
        })
    , 0);
    _tablefoot_outlines.position.z = -0.5;
    _tablefoot_outlines.scale.set(1.01,1.05,1.05);
    _tablefoot.add(_tablefoot_outlines);

    _tablefoot.castShadow = true;
    _tablefoot.receiveShadow = true;



    _tablefoot.rotation.x = 0.3;
    _tablefoot.position.x = 0;
    _tablefoot.position.y = tablefootSurfaceDim[1]-6.3;
    _tablefoot.position.z = -90;

    level.add(_tablefoot);



//
//    _tablefoot = new Physijs.BoxMesh(
//        new THREE.BoxGeometry(tablefootSurfaceDim[0], tablefootSurfaceDim[1]-10, tablefootSurfaceDim[2]),
//        new THREE.MeshPhongMaterial({
//            color: cgreen
//        }), 0
//    );
//    _tablefoot.position.x = 0;
//    _tablefoot.position.y = tablefootSurfaceDim[1]-10;
//    _tablefoot.position.z = 110;
//    _tablefoot.castShadow = true;
//    _tablefoot.receiveShadow = true;
//
//    level.add(_tablefoot);

    //Add table

    var _table_geometry = new THREE.BoxGeometry(tableSurfaceDim[0], tableSurfaceDim[1], tableSurfaceDim[2]);

    _table = new Physijs.BoxMesh(
        _table_geometry,
        new THREE.MeshPhongMaterial({
            color: 0xffffff
        }), 0
    );


    var _table_outlines = new Physijs.BoxMesh(
        _table_geometry,
        new THREE.MeshPhongMaterial({
            color: 0x000000
        })
        , 0);
    _table_outlines.position.z = -2;
    _table_outlines.position.y = -0.5;
    _table_outlines.scale.set(1.01,1.05,1.1);

    _table.add(_table_outlines);



    _table.position.x = 0;
    _table.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2 ;
    _table.position.z = -90;
    _table.castShadow = true;
    _table.receiveShadow = true;

    level.add(_table);

    _table = new Physijs.BoxMesh(
        new THREE.BoxGeometry(tableSurfaceDim[0]+100, tableSurfaceDim[1], tableSurfaceDim[2]),
        new THREE.MeshPhongMaterial({
            color: 0xffffff
        }),
    0);

    _table_outlines = new Physijs.BoxMesh(
        new THREE.BoxGeometry(tableSurfaceDim[0]+100, tableSurfaceDim[1], tableSurfaceDim[2]),
        new THREE.MeshPhongMaterial({
            color: 0x000000
        }),
    0);

    _table_outlines.position.z = -0.5;
    _table_outlines.position.y = -0.2;
    _table_outlines.scale.set(1.01, 1, 1);

    _table.add(_table_outlines);

    _table.position.x = 0;
    _table.position.y = tablefootSurfaceDim[1]-10 +tablefootSurfaceDim[1]/2 ;
    _table.position.z =  110;
    _table.castShadow = true;
    _table.receiveShadow = true;

    level.add(_table);

    //Add Wall to level
    var phone_t = new THREE.MeshPhongMaterial({
        map: THREE.ImageUtils.loadTexture('images/phone_face.png')
    });
    var transparent_side =  new THREE.MeshPhongMaterial({
        color:0xfcd625
    });
    var phone_materials = [
        transparent_side,
        transparent_side,
        phone_t,
        transparent_side,
        transparent_side,
        transparent_side
    ];
    var _phone = new Physijs.BoxMesh(
        new THREE.BoxGeometry(10, 1, 14),
        new THREE.MeshFaceMaterial(phone_materials),
        0
    );
    _phone.position.x = -50;
    _phone.position.y = 3;
    _phone.position.z = -5;
    _phone.rotation.y = - 0.3;
    _table.add(_phone);


    scene.add(level);



    // material texture
    var texture = new THREE.Texture( generateTexture() );
    texture.needsUpdate = true; // important!

    // material
    var material = new THREE.MeshBasicMaterial( {
        color: 0xffffff,
        shininess: 10,
        transparent:true,
        opacity:0.2,
        map: texture,
        side : 2
    } );


    var _spot_fake = new THREE.Mesh(
        new THREE.CylinderGeometry(
            20, 150, 400, 32
        ),
        material
        , 0);


    _spot_fake.scale.set(0.3,1, 1);
    _spot_fake.rotation.y = Math.PI/2;
    _spot_fake.receiveShadow = false;
    _spot_fake.position.x = 0;
    _spot_fake.position.y = 150;
    _spot_fake.position.z = -110;
    scene.add(_spot_fake);

    // SKYDOME

    var vertexShader = document.getElementById( 'vertexShader' ).textContent;
    var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
    var uniforms = {
        topColor: 	 { type: "c", value: new THREE.Color( 0x000000 ) },
        bottomColor: { type: "c", value: new THREE.Color( 0x3e3c3c ) },
        offset:		 { type: "f", value: 10 },
        exponent:	 { type: "f", value: 0.6 }
    }
    uniforms.topColor.value.copy( hemiLight.color );

    scene.fog.color.copy( uniforms.bottomColor.value );

    var skyGeo = new THREE.SphereGeometry( 1000, 64, 15 );
    var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

    var sky = new THREE.Mesh( skyGeo, skyMat );
    scene.add( sky );


    sphere_traj = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshBasicMaterial({
            color:0xffffff
        })
    );



    sphere_traj.__dirtyPosition = true;

    sphere_traj.position.set(0,20,0);
    scene.add(sphere_traj)

//    trajCap.initial();
}


function generateTexture() {

    var size = 150;
    // create canvas
    canvas = document.createElement( 'canvas' );
    canvas.width = size;
    canvas.height = size;

    // get context
    var context = canvas.getContext( '2d' );

    // draw gradient

    context.rect( 0, 0, size-50, size );

    var gradient = context.createLinearGradient( 0, 0, size-50, size );

    gradient.addColorStop(0, '#ffffff'); // light blue
    gradient.addColorStop(1, 'transparent'); // dark blue
    context.fillStyle = gradient;
    context.fill();

    return canvas;

};var frontLight	= new THREE.DirectionalLight(0xffffff, 0.2);

var backLight	= new THREE.DirectionalLight(0xffffff, 0.7);

var ambientLight = new THREE.AmbientLight( 0xfefefe );

var rightLight	= new THREE.DirectionalLight(0xfefefe, 0.4);

var leftLight	= new THREE.DirectionalLight(0xfefefe, 0.3);

var pointlightbar;

function create_lights(){



    // LIGHTS

    var central_point = new THREE.PointLight( 0xffffff, 1, 300 );
    central_point.position.set(0,15,0);

    scene.add( central_point );

    var VlspotLight = new THREE.SpotLight( 0xffffff );
    VlspotLight.position.set( 0, 200, -110 );
    VlspotLight.target.position.set(0,50,-110);
    VlspotLight.target.updateMatrixWorld();
    VlspotLight.intensity = 1;

    scene.add( VlspotLight );


    pointlightbar = new THREE.PointLight( 0xfcd625, 2, 50 );
    pointlightbar.position.set( -8, 200, -420 );

    pointlightbar.animeLight = function(){
        if(Math.random() > 0.9){
            this.intensity = 0.2;
        }else{
            this.intensity = 2;
        }
    };

    scene.add( pointlightbar );




    var PlspotLight = VlspotLight.clone();
    PlspotLight.position.set( 0, 200, 120 );
    PlspotLight.target.position.set(0,50,120);
    PlspotLight.target.updateMatrixWorld();
    PlspotLight.intensity = 1;



    scene.add( PlspotLight );


    var backspotLight = new THREE.SpotLight( 0xffffff );
    backspotLight.position.set( 0, 300, -120 );
    backspotLight.target.position.set(0,20,-400);
    backspotLight.target.updateMatrixWorld();
    backspotLight.intensity = 0.7;
    scene.add( backspotLight );

    backspotLight = new THREE.SpotLight( 0xffffff );
    backspotLight.position.set( 500, 300, -120 );
    backspotLight.target.position.set(200,20,-300);
    backspotLight.target.updateMatrixWorld();
    backspotLight.intensity = 0.7;
    scene.add( backspotLight );

    backspotLight = new THREE.SpotLight( 0xffffff );
    backspotLight.position.set( -500, 300, -120 );
    backspotLight.target.position.set(-200,20,-300);
    backspotLight.target.updateMatrixWorld();
    backspotLight.intensity = 0.7;
    scene.add( backspotLight );

//    var light = new THREE.DirectionalLight( 0xffffff, 0.7 ); // soft white light

//    scene.add( light );

//
//
//
//    var directionalLight = new THREE.DirectionalLight(/*Math.random() * 0xffffff*/0xeeeeee );
//    directionalLight.position.set( .2, -1, .2 );
//    directionalLight.position.normalize();
//    scene.add( directionalLight );



// LIGHTS

//    var whitelight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );
//    whitelight.color.setHex( 0xefefef );
//    whitelight.groundColor.setHSL( 0.2,0.2,0.2 );
//    whitelight.position.set( 0, 300, 0 );
//    scene.add( whitelight );



    hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.8 );
    hemiLight.color.setHex( 0x3f3f3f );
    hemiLight.groundColor.setHSL( 0.2,0.2,0.2 );
    hemiLight.position.set( 0, 300, 0 );
    scene.add( hemiLight );

//    var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
//    dirLight.color.setHSL( 0.1, 1, 0.95 );
//    dirLight.position.set( -1, 90, 1 );
//    dirLight.position.multiplyScalar( 50 );
//    scene.add( dirLight );
//
//    dirLight.castShadow = true;
//
//    dirLight.shadowMapWidth = 2048;
//    dirLight.shadowMapHeight = 2048;
//
//    var d = planeHEIGHT/2;
//
//    dirLight.shadowCameraLeft = -d;
//    dirLight.shadowCameraRight = d;
//    dirLight.shadowCameraTop = d;
//    dirLight.shadowCameraBottom = -d;
//
//    dirLight.shadowCameraFar = 3500;
//    dirLight.shadowCameraNear = 1;
//    dirLight.shadowBias = -0.0001;
//    dirLight.shadowDarkness = 0.35;




}
;

var Player = {
    score : 0,
    launched : 0,
    isPlaying : true,
    totalLaunched : 0,
    lives : 0,
    drunked : 1,
    capmat : null,
    outline : '',
    initialize : function(){

        if(!this.capmat){
            this.capmat = caps_material.chimey.clone();
        }

        var bottle_material = new THREE.MeshBasicMaterial( {  color:Player.capmat.materials[1].color,side:2 } )

        bottle_geo.buffersNeedUpdate = true;
        bottle_geo.uvsNeedUpdate = true;

        this.bottle = new Physijs.CylinderMesh(
            bottle_geo,
            bottle_material,
            520, {friction : 0.1, restitution : 0.1}
        );
        var outline_material =  new THREE.MeshBasicMaterial( {  color: 0x0000,  shininess: 10,side:1 } );
        Player.outline = new Physijs.CylinderMesh(
            bottle_geo,
            outline_material,
            0
        );

        Player.outline.scale.set(1.1,1.1,1.1);
        Player.outline.rotation.x = 0.04;
        Player.outline.position.z = -0.13;
        Player.outline.position.y = -0.15;

        var subock = new Physijs.BoxMesh(
            new THREE.CircleGeometry( 0.5, 64 ),
            new THREE.MeshLambertMaterial({
                color: 0x000000,
                side:2
            })
            , 0);
        subock.rotation.x = Math.PI/2;
        subock.position.x = 0;
        subock.position.y = -1.7;
        subock.position.z = 0;

        //Add Wall to level
        var sticker_t = new THREE.MeshBasicMaterial({
            map: THREE.ImageUtils.loadTexture('images/test_etiquette2.png'),
            side:2,
            transparent:true,
            opacity:1

        });
        var transparent_side =  new THREE.MeshBasicMaterial({
            color:0xfcd625,
            transparent:true,
            opacity:0
        });
        var sticker_materials = [
            transparent_side,
            transparent_side,
            transparent_side,
            transparent_side,
            sticker_t,
            transparent_side
        ];
        var _sticker = new Physijs.BoxMesh(
            new THREE.BoxGeometry(0.8, 1, 0.1),
            new THREE.MeshFaceMaterial(sticker_materials),
            0
        );
        _sticker.position.x = 0;
        _sticker.position.y = -0.3;
        _sticker.position.z = 0.45;
        Player.bottle.add(_sticker);


        this.bottle.add(Player.outline);
        this.bottle.add(subock);

        this.bottle.scale.set(10,12,10);

        this.bottle.castShadow = true;
        this.bottle.receiveShadow = true;
        this.bottle.name = 'plBottle';


        console.log(Player.bottle);
        Player.place({x:0, z:112});
        Player.generateBottle();


    },
    place : function(axis){
        this.bottle.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2+13;
        this.bottle.position.x = axis.x;
        this.bottle.position.z = axis.z;
    },
    generateBottle : function(){
        scene.add(Player.bottle);
    },
    generateCaps : function(){
//        var materialColor = new THREE.Color();
//        materialColor.setHex( cyellow );
//        var phongMaterial = createShaderMaterial("phongDiffuse", rightLight);
//        phongMaterial.uniforms.uMaterialColor.value.copy(materialColor);
//        phongMaterial.side = THREE.DoubleSide;

//        var caps_material = Physijs.createMaterial(
//            new THREE.MeshLambertMaterial(mat_caps.materials)
////            phongMaterial
//        );

//        Player.capmat.materials[1].color.setHex(cblue);

        this.bottlecaps = new Physijs.CylinderMesh(geo_caps, Player.capmat, 0.3);
        this.bottlecaps.castShadow = true;
        this.bottlecaps.receiveShadow = true;

        this.bottlecaps.scale.set(capModelscale,capModelscale,capModelscale);
        this.bottlecaps.rotation.x = Math.PI;

        this.bottlecaps.position.y = Player.bottle.position.y + 22;
        this.bottlecaps.position.x = Player.bottle.position.x;
        this.bottlecaps.position.z = Player.bottle.position.z;


        var neck = new Physijs.CylinderMesh(
            new THREE.CylinderGeometry(2, 2, 0.4, 10, 10 ),
            Physijs.createMaterial(
                new THREE.MeshLambertMaterial({
                    color: 0xffffff,
                    transparent : true,
                    opacity:0
                }))
            ,0);
        neck.position.x = 0;
        neck.position.y = 1;
        neck.position.z = 0;

        var sub = new Physijs.CylinderMesh(
            new THREE.CylinderGeometry(1.5, 1.5, 0, 32, 32 ),
                new THREE.MeshLambertMaterial({
                    color: Player.capmat.materials[1].color,
                    transparent : true,
                    opacity:1
                })
            ,0);
        sub.position.x = 0;
        sub.position.y = 0.3;
        sub.position.z = 0;


        this.bottlecaps.add(sub);
        this.bottlecaps.add(neck);

        this.bottlecaps.name = 'plCap';
        this.bottlecaps.collided = false;
        scene.add(Player.bottlecaps);
    }

}

var perfectShoot = [
    {
        y : 140,
        x  : -2,
        pwr : 30
    },
    {
        y : 100,
        x  : -1,
        pwr : 80
    },
    {
        y : 130,
        x  : 2,
        pwr : 35
    },
    {
        y : 180,
        x  : -2,
        pwr : 21
    }
];


var Viensla = {
    score : 0,
    launched : 0,
    totalLaunched : 0,
    isPerfect : false,
    imprecision : 10,
    isPlaying : false,
    lives : 0,
    capmat : null,
    initialize : function(){

        if(!this.capmat){
            this.capmat = caps_material.ptp.clone();
        }

        var bottle_material = Physijs.createMaterial(
            new THREE.MeshBasicMaterial( {  color: Viensla.capmat.materials[1].color,  shininess: 10,side:2 } )
        );

        this.bottle = new Physijs.CylinderMesh(
            bottle_geo,
            bottle_material,
            320, {friction : 0.1, restitution : 0.1}
        );

        this.bottle.scale.set(10,12,10);

        this.bottle.castShadow = false;

        this.bottle.receiveShadow = true;

        this.bottle.name = 'vlBottle';

        var outline_material =  new THREE.MeshBasicMaterial( {  color: 0x0000,  shininess: 10,side:1 } );

        var outlines = new Physijs.CylinderMesh(
            bottle_geo,
            outline_material,
            0
        );
        outlines.scale.set(1.12,1.12,1.12);
        outlines.rotation.x = 0.04;
        outlines.position.z = -0.13;
        outlines.position.y = -0.15;

        var subock = new Physijs.BoxMesh(
            new THREE.CircleGeometry( 0.5, 64 ),
            new THREE.MeshLambertMaterial({
                color: 0x000000,
                side:2
            })
            , 0);

        subock.rotation.x = Math.PI/2;
        subock.position.x = 0;
        subock.position.y = -1.7;
        subock.position.z = 0.1;







        this.bottle.add(subock);

        this.bottle.add(outlines);




        Viensla.place({x:0, z:-92});
        Viensla.generateBottle();

    },
    place : function(axis){
        this.bottle.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2+23;
        this.bottle.position.x = axis.x;
        this.bottle.position.z = axis.z;
    },
    generateBottle : function(){
        scene.add(Viensla.bottle);
        Viensla.generateCaps();
    },
    generateCaps : function(){

//        var materialColor = new THREE.Color();
//        materialColor.setHex( cgreen );
//        var phongMaterial = createShaderMaterial("phongDiffuse", rightLight);
//        phongMaterial.uniforms.uMaterialColor.value.copy(materialColor);
//        phongMaterial.side = THREE.DoubleSide;
//
//
//        var caps_material = Physijs.createMaterial(
////            new THREE.MeshLambertMaterial(mat_caps.materials)
//                phongMaterial
//        );
//        caps_material.side = 2;


//        Viensla.capmat.materials[1].color.setHex(ptpyellow);

        this.bottlecaps = new Physijs.CylinderMesh(geo_caps, Viensla.capmat,  0.3);
        this.bottlecaps.castShadow = true;
        this.bottlecaps.receiveShadow = true;

        this.bottlecaps.scale.set(capModelscale,capModelscale,capModelscale);
        this.bottlecaps.rotation.x = Math.PI;

        this.bottlecaps.position.y = Viensla.bottle.position.y + 22;
        this.bottlecaps.position.x = Viensla.bottle.position.x;
        this.bottlecaps.position.z = Viensla.bottle.position.z;

        var neck = new Physijs.CylinderMesh(
            new THREE.CylinderGeometry(2, 2, 0.4, 10, 10 ),
            Physijs.createMaterial(
                new THREE.MeshLambertMaterial({
                    color: 0xffffff,
                    transparent : true,
                    opacity:0
                }))
            ,0);
        neck.position.x = 0;
        neck.position.y = 1;
        neck.position.z = 0;

        this.bottlecaps.add(neck);

        this.bottlecaps.name = 'vlCap';
        this.bottlecaps.collided = false;

        scene.add(Viensla.bottlecaps);
    },
    launchCaps : function(){
        Viensla.isPlaying = true;

        var  launchVector = new THREE.Vector3,
            _vector = new THREE.Vector3,
            _angVector = new THREE.Vector3,
            _posVector = new THREE.Vector3,
            randomY = Math.random()*20 + 80,
            randomX = Math.random()*10 - 5,
            shot = Math.round(Math.random()*3);


        shot = perfectShoot[shot];

        globalDirection = -1;

        power = Math.round(shot.pwr +  (Math.random()-0.5) * Viensla.imprecision);

        randomY = Math.round(shot.y +  (Math.random()-0.5) * Viensla.imprecision);

        randomX = Math.round(shot.x +  (Math.random()-0.5) * Viensla.imprecision);


        if(Viensla.isPerfect){
            var alea = Math.round(Math.random()*3);
            randomY = perfectShoot[alea].y;
            randomX  = perfectShoot[alea].x;
            power = perfectShoot[alea].pwr;
        }

        randomY += 25;

        Player.isPlaying = false;

        _posVector.set(randomX,randomY, playerDistance*globalDirection + 25);

        create_caps('vl');

        playedCaps.position.copy(_posVector);

        playedCaps.__dirtyPosition = true;
        playedCaps.floating = false;

        _vector.set( 1, 1, 1 );
        _angVector.set( Math.random()*10, Math.random()*10, Math.random()*20);
        playedCaps.setAngularFactor( _vector );

        playedCaps.setLinearFactor( _vector );
        launchVector.set(1,-3, - power * strengh * globalDirection);
        playedCaps.setLinearVelocity( launchVector );
        playedCaps.setAngularVelocity( _angVector );

        playedCaps = null;

    }


}







document.addEventListener(
    'keydown',
    function( ev ) {
        console.log(ev.keyCode);
        switch( ev.keyCode ) {
            case 37:
                // Left
                camera.initialpos.y +=5;
                break;

            case 39:
                // Right
                camera.initialpos.y -=5;

                break;

            case 38:
                // Up
                camera.initialpos.z +=5;

                break;

            case 40:
                camera.initialpos.z -=5;

//                Viensla.launchCaps();
                break;

            case 32:
                // space
//                create_caps();
                break;

            case 67:
//                lookatobj = ball;
                break;

            case 86:
                console.log('bottlecaps vl');
                lookatobj = BottleViensla.bottle;
                break;

            case 66:
                lookatobj = scene;
                break;

            case 65 :
                if(axes.presence){
                    axes.traverse( function ( object ) { object.visible = false; } );
                    axes.presence = false;
                }else{
                    axes.traverse( function ( object ) { object.visible = true; } );
                    axes.presence = true;
                }
            break;

            case 13:
                $('#party').click();
                break;
        }
    }
);
;var Sounds;

(function ($){
    var path = 'assets/sounds/';
    Sounds = {
        simpletap1 : new Audio(path+"choc_simple_1.mp3"),
        simpletap2 : new Audio(path+"choc_simple_2.mp3"),
        simpletap3 : new Audio(path+"choc_simple_3.mp3"),
        clink : new Audio(path+"clink.mp3"),
        capcap : new Audio(path+"capcap.mp3"),
        pschit1 : new Audio(path+"pschit_1.mp3"),
        pschit2 : new Audio(path+"pschit_2.mp3"),

        mute : true
    }
})(jQuery);;

THREE.ShaderTypes = {

    'phongDiffuse' : {

        uniforms: {

            "uDirLightPos":	{ type: "v3", value: new THREE.Vector3() },
            "uDirLightColor": { type: "c", value: new THREE.Color( 0xffffff ) },

            "uMaterialColor":  { type: "c", value: new THREE.Color( 0xffffff ) },

            uKd: {
                type: "f",
                value: 0.9
            },
            uBorder: {
                type: "f",
                value: 0.8
            }
        },

        vertexShader: [

            "varying vec3 vNormal;",
            "varying vec3 vViewPosition;",

            "void main() {",

            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "vNormal = normalize( normalMatrix * normal );",
            "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "vViewPosition = -mvPosition.xyz;",

            "}"

        ].join("\n"),

        fragmentShader: [

            "uniform vec3 uMaterialColor;",

            "uniform vec3 uDirLightPos;",
            "uniform vec3 uDirLightColor;",

            "uniform float uKd;",
            "uniform float uBorder;",

            "varying vec3 vNormal;",
            "varying vec3 vViewPosition;",

            "void main() {",

            // compute direction to light
            "vec4 lDirection = viewMatrix * vec4( uDirLightPos, 0.8 );",
            "vec3 lVector = normalize( lDirection.xyz );",

            // diffuse: N * L. Normal must be normalized, since it's interpolated.
            "vec3 normal = normalize( vNormal );",
            //was: "float diffuse = max( dot( normal, lVector ), 0.0);",
            // solution
            "float diffuse = dot( normal, lVector );",
            "if ( diffuse > 0.6 ) { diffuse = 1.0; }",
            "else if ( diffuse > -0.2 ) { diffuse = 0.7; }",
            "else { diffuse = 0.3; }",

            "gl_FragColor = vec4( uKd * uMaterialColor * uDirLightColor * diffuse, 1.0 );",

            "}"

        ].join("\n")

    }

};



function createShaderMaterial(id, light) {

    var shader = THREE.ShaderTypes[id];

    var u = THREE.UniformsUtils.clone(shader.uniforms);

    var vs = shader.vertexShader;
    var fs = shader.fragmentShader;

    var material = new THREE.ShaderMaterial({ uniforms: u, vertexShader: vs, fragmentShader: fs });

    material.uniforms.uDirLightPos.value = light.position;
    material.uniforms.uDirLightColor.value = light.color;

    return material;

}
;
var trajLine;

var trajCap = {
    line : '',
    curve : '',
    geo : '',
    sub : 20,
    initial : function(){
        var sub = 20;
        var geo = new THREE.Geometry();
        var curve = new THREE.QuadraticBezierCurve3();

        curve.v0 = new THREE.Vector3(0, 0, 0);
        curve.v1 = new THREE.Vector3(0, 10, -10);
        curve.v2 = new THREE.Vector3(0, 20, -100);

        for (var j = 0; j < sub; j++) {
           geo.vertices.push( curve.getPoint(j / sub) )
        }

        var material = new THREE.LineDashedMaterial( { color: 0xffffff, dashSize: 30, gapSize: 10, linewidth:2} );

        trajLine = new THREE.Line(geo, material, THREE.LinePieces);
        trajLine.position.z = 100;
        trajLine.position.y = 130;

        trajLine.__dirtyPosition = true;

        scene.add(trajLine);
    },

    calculate : function(pos1, pos2, pos3){

//        scene.remove(trajCap.line);
        /*
        console.log(pos1, pos2, pos3);

        trajCap.curve.v0 = pos1;
        trajCap.curve.v1 = pos2;
        trajCap.curve.v2 = pos3;

        for (var j = 0; j < trajCap.sub; j++) {
            trajCap.geo.vertices.push( trajCap.curve.getPoint(j /  trajCap.sub) )
        }


        var material = new THREE.LineDashedMaterial( { color: 0xffffff, dashSize: 30, gapSize: 10, linewidth: 2 } );
        trajCap.line = new THREE.Line(trajCap.geo, material, THREE.LinePieces);
        trajCap.line.__dirtyPosition = true;

        */

//        trajCap.line.position.set(pos1);
//        trajCap.line.__dirtyPosition = true;


        //scene.add(trajCap.line);


    }
}

