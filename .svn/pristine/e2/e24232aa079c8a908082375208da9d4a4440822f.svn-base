
function create_camera(){

    camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

    var camera_xangle = 30;
    var camera_yangle = 80;



    camera.position.set(camera_xangle, camera_yangle, 90);
    camera.lookAt(scene);

    scene.add(camera);


    mouse = {x : 0, y : 0};

    document.addEventListener('mousemove', function(event){
        mouse.x	= (event.clientX / window.innerWidth ) - 0.5;
        mouse.y	= (event.clientY / window.innerHeight) - 0.5;


        camera.position.x += (mouse.x * 10 - camera.position.x) * (0.5*3) + camera_xangle;
        camera.position.y += (mouse.y * 5 - camera.position.y) * (0.2*3) + camera_yangle;
        camera.lookAt(lookatobj);
    }, false);

}
function create_lights(){
    var ambientLight= new THREE.AmbientLight( 0x020202 );
    scene.add( ambientLight);

    var frontLight	= new THREE.DirectionalLight(0xffffff);

    frontLight.position.set(0, 100, 60);
    frontLight.castShadow = true;
    frontLight.shadowDarkness = .3;
    frontLight.shadowBias = -.0001;
    frontLight.shadowCameraNear = 1;
    frontLight.shadowMapWidth = 2048;
    frontLight.shadowMapHeight = 2048;
    frontLight.shadowCameraLeft = planeWIDTH/2;
    frontLight.shadowCameraTop = - planeHEIGHT/2;
    frontLight.shadowCameraRight = - planeWIDTH/2;
    frontLight.shadowCameraBottom = planeHEIGHT/2;

    scene.add( frontLight );

    var backLight	= new THREE.DirectionalLight('white', 0.75);
    backLight.position.set(0, -100, -60);
    scene.add( backLight );

}

function create_plane(){
    plane = new Physijs.BoxMesh(
        new THREE.CubeGeometry(planeWIDTH, planeHEIGHT, 35),
        table_material ,0, { restitution: .2, friction: .8 });
    plane.rotation.x = Math.PI/2;
    plane.position.y = -.5;
    //plane.rotation.y = Math.PI / 24;
    plane.receiveShadow = true;

    scene.add(plane);
}
function create_bottle(xaxis){

    bottle = new Physijs.CylinderMesh(
        new THREE.CylinderGeometry(3, 5, 30, 32),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: 0xffffff
            }), 0.4, 0.8),
        0);

    bottle.position.y = 32;
    bottle.position.x = xaxis;
    bottle.position.z = -80;

    bottle.castShadow = true;
    bottle.receiveShadow = true;
    scene.add(bottle);

    lookatobj = bottle;

    create_bottlecaps();
}

function create_bottlecaps(){
    bottlecaps = new Physijs.CylinderMesh(caps_geometry, bottlecaps_material, 0.3);

    bottlecaps.position.y = bottle.position.y + 16;
    bottlecaps.position.x = bottle.position.x;
    bottlecaps.position.z = bottle.position.z;

    bottlecaps.castShadow = true;
    bottlecaps.receiveShadow = true;
    scene.add(bottlecaps);

}

function create_pilone(){


    pilone = new Physijs.BoxMesh(
        new THREE.BoxGeometry(3, 3, 2, 100, 100),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: 0xeeeeee,
                transparent: true,
                opacity: 0.3
            }), 0.4, 0.8)
        ,0);


    pilone.position.y = ball.position.y - 1;
    pilone.position.z = ball.position.z;
    pilone.rotation.x = Math.PI / -2;

    scene.add(pilone);

}



function buildAxes( length ) {
    var axes = new THREE.Object3D();
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
    return axes;
}

function buildAxis( src, dst, colorHex, dashed ) {
    var geom = new THREE.Geometry(),
        mat;

    if(dashed) {
        mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
    } else {
        mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
    }

    geom.vertices.push( src.clone() );
    geom.vertices.push( dst.clone() );
    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

    var axis = new THREE.Line( geom, mat, THREE.LinePieces );

    return axis;

}


document.addEventListener(
    'keydown',
    function( ev ) {
        console.log(ev.keyCode);
        switch( ev.keyCode ) {
            case 37:
                // Left


                break;

            case 39:
                // Right

                break;

            case 38:
                // Up
                capsYpos++;
                ball.position.y = capsYpos;
                pilone.position.y = capsYpos - 1;
                break;

            case 40:
                // Down
                capsYpos--;
                ball.position.y = capsYpos;
                pilone.position.y = capsYpos - 1;

                break;

            case 32:
                // space
                create_caps();
                break;

            case 67:
                lookatobj = ball;
                break;

            case 86:
                lookatobj = bottlecaps;
                break;

            case 66:
                lookatobj = scene;
                break;

            case 65 :
                if(axes.presence){
                    axes.traverse( function ( object ) { object.visible = false; } );
                    axes.presence = false;
                }else{
                    axes.traverse( function ( object ) { object.visible = true; } );
                    axes.presence = true;
                }
                break;
        }
    }
);
