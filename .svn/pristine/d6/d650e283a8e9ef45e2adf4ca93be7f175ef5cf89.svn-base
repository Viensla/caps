/* colors */
var cblue = 0x67AAC1;
var cyellow = 0xF7D443;
var cgreen = 0x78AD60;
var cred = 0xC1676A;



var container, scene, renderer, light, ball, plane, bottle, bottlecaps, axes, initEventHandling, initScene;
var WIDTH, HEIGHT, planeWIDTH, planeHEIGHT;

var elements = [], playedCaps = null, mouse_position = new THREE.Vector3, block_offset = new THREE.Vector3, _i, _v3 = new THREE.Vector3, intersect_plane, lookatobj, pilone, mouse,
    mouse3D = new THREE.Vector3;

var _nullVector = new THREE.Vector3(0,0,0), DCMP  = new THREE.Vector3(0,0,0);

var onRenderFcts= [];

var lastTimeMsec= null;

var capsYpos = 80;


var movingCaps = null;

var clock = new THREE.Clock(), dir, distance;

var holdingDown = false;


Physijs.scripts.worker = '/js/physijs/physijs_worker.js';
Physijs.scripts.ammo = 'ammo.js';

container = document.querySelector('.viewport');

WIDTH = window.innerWidth;
HEIGHT = window.innerHeight;



var playerDistance = 85;
var globalDirection = 1;

var capsDae;
var capsMesh;

var capModelscale = 1.5;

var geo_caps, mat_caps, bottle_geo, bottle_mat;

var $plpart, $vlpart, plscore = 0, vlscore = 0;

function loadCollada(){
//    var loader = new THREE.ColladaLoader();
//    loader.options.convertUpAxis = true;
//    loader.load('models/caps.dae', function (collada) {
//        capsDae = collada.scene;
//        console.log(capsDae);
//
//        capsDae.scale.x = capsDae.scale.y = capsDae.scale.z = 0.06;
//        capsDae.updateMatrix();
//        capsMesh = capsDae.children[0];
//        caps_test_geometry = new THREE.Mesh( capsMesh.geometry, caps_material);
//
//        initScene();
//    });

    var loader = new THREE.JSONLoader();
    loader.load( 'models/cap_model.json', function ( cap_geometry, cap_materials ) {
        loader.load( 'models/bottle_model.json', function ( bottle_geometry, bottle_materials ) {
            bottle_geo = bottle_geometry;
            console.log(bottle_geo,  bottle_materials[0]);

            bottle_mat = new THREE.MeshFaceMaterial( bottle_materials );

            cap_materials[0].side = 2;
//
            var material = cap_materials[ 0 ];
//        material.morphTargets = true;
//        material.color.setHex( 0xffaaaa );
//        material.ambient.setHex( 0x222222 );

            geo_caps = cap_geometry;

            mat_caps = new THREE.MeshFaceMaterial( cap_materials );

            console.log(mat_caps.materials[0]);

            initScene();


        });



    });


}

var table_material = Physijs.createMaterial(
    new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/wood.jpg' ), ambient: 0xFFFFFF, opacity: 1, transparent: true }),
    .9, // high friction
    .2 // low restitution
);
table_material.map.wrapS = table_material.map.wrapT = THREE.RepeatWrapping;
table_material.map.repeat.set( 5, 5 );

var chimey_material = Physijs.createMaterial(
    new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/caps1.jpg' ), ambient: 0xFFFFFF, opacity: 1, transparent: true }),
    .9, // high friction
    .2 // low restitution
);
chimey_material.map.wrapS = chimey_material.map.wrapT = THREE.RepeatWrapping;
chimey_material.map.repeat.set( 5, 5 );

var caps_test_geometry;
var caps_geometry;
caps_geometry = new THREE.CylinderGeometry(4, 3, 1.2, 32);

var caps_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
            color: cred
        }), 0.4, 0.8);



var bottlecaps_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
            color: cgreen
        }), 0.4, 0.8),

initScene = function() {

    $plpart = $('.pl-part');
    $vlpart = $('.vl-part');

    scene = new Physijs.Scene();

    scene.setGravity(new THREE.Vector3( 0, -80, 0 ));

    scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

    renderer = new THREE.WebGLRenderer({
        antialias: true
    });

    renderer.setSize(WIDTH, HEIGHT);
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFShadowMap;
    renderer.shadowMapAutoUpdate = true;

    renderer.gammaInput = true;
    renderer.gammaOutput = true;

    renderer.setClearColor( scene.fog.color, 1 );
    container.appendChild(renderer.domElement);

    create_camera();

    create_lights();

    create_table();

    // ADD AXES *******************************************************
    axes = buildAxes( 1000 );
    axes.presence = false;
    axes.traverse( function ( object ) { object.visible = false; } );
    scene.add(axes);

    BottleViensla.initialize();
    BottlePlayer.initialize();

    create_caps();

    lookatobj = BottleViensla.bottle;

    scene.simulate();

    initEventHandling();

    render();

    scene.addEventListener('update', function() {

        if(playedCaps){
            playedCaps.position.copy(DCMP);
        }

        if(holdingDown){
            setPower();
        }

        scene.simulate(undefined, 2);

    });
}







initEventHandling = (function() {
    var projector, ray, intersection,
        handleMouseDown, handleMouseMove, handleMouseUp,
        launchVector = new THREE.Vector3,
        _vector = new THREE.Vector3,
        _angVector = new THREE.Vector3;


    handleMouseDown = function( evt ) {

        if(!playedCaps) return;

        holdingDown = true;

        launchVector.set(1,-3, -100);

        power = 0;
        $('.powerbar').fadeIn();
    };

    handleMouseMove = function( evt ) {
         var mouseX = evt.clientX,
             mouseY = evt.clientY;


        $('.powerbar').css({left:mouseX+50, top:mouseY-50});


        if(!playedCaps) return;
//        if(!holdingDown){
            mouse3D.set(
                ( mouseX / window.innerWidth ) * 2 - 1,
                - ( mouseY / window.innerHeight ) * 2 + 1,
                1 );

            mouse3D.unproject(camera);

            dir = mouse3D.sub( camera.position ).normalize();

            distance = - camera.position.z / dir.z;

            DCMP = camera.position.clone().add( dir.multiplyScalar(distance/2) );

            DCMP.z = playerDistance*globalDirection;
//        }


    };

    handleMouseUp = function( evt ) {

        if(!playedCaps) return;

        holdingDown = false;

        playedCaps.__dirtyPosition = true;

        _vector.set( 1, 1, 1 );
        _angVector.set( Math.random(), Math.random()*10, Math.random()*20);

        playedCaps.setAngularFactor( _vector );

        playedCaps.setLinearFactor( _vector );
        launchVector.set(1,-3, -power*strengh*globalDirection);
        playedCaps.setLinearVelocity( launchVector );
        playedCaps.setAngularVelocity( _angVector );

        playedCaps.position.copy(DCMP);

        playedCaps = null;

        power = 0;

        $('.powerbar').fadeOut();

        setTimeout(function(){
            change_camera();
            create_caps();
        }, 2000);

    };

    return function() {
        renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
        renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
        renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
    };
})();







function render() {

//    if (ball.position.y <= -50 || ball.position.z <= -500) {
//        create_caps();
//    }
//
//    if(ball.position.z <= -100){
//        create_caps();
//    }

//    if(ball.position.y <= 10){
//        ball.setAngularFactor( _nullVector );
//        ball.setLinearFactor( _nullVector );
//    }

    if(BottleViensla.bottlecaps.position.y <= BottleViensla.bottle.position.y){
        BottleViensla.generateCaps();
        plscore++;
        $plpart.find('.score').text(plscore);
    }

    if(BottlePlayer.bottlecaps.position.y <= BottlePlayer.bottle.position.y){
        BottlePlayer.generateCaps();
        vlscore++;
        $vlpart.find('.score').text(vlscore);
    }

    camera.lookAt(lookatobj.position);



    var time = Date.now() * 0.0005;

//    animateFloatingLights(time);

    pointLight.position.x = Math.sin( time ) * 3000;
    pointLight.position.y = 600;
    pointLight.position.z = Math.cos( time ) * 3000;


    renderer.render(scene, camera);
    requestAnimationFrame(render);


}



function create_caps(){
    var randomCaps = Math.random() > 0.98;
    var mass = randomCaps ? 4 : 2;


//    var imgTexture2 = THREE.ImageUtils.loadTexture( "images/caps1.jpg" );
//    imgTexture2.wrapS = imgTexture2.wrapT = THREE.RepeatWrapping;
//    imgTexture2.anisotropy = 16;
//    var shininess = 50, specular = 0x333333, bumpScale = 1, shading = THREE.SmoothShading;


    var caps_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial(mat_caps.materials)
    );

    caps_material.side = 2;
    if(randomCaps){
        caps_material.color.setHex( cred );
    }else{
        caps_material.color.setHex( cblue );
    }



    ball = new Physijs.CapsuleMesh(geo_caps, caps_material, mass, {friction : 0, restitution : 0.8});

    ball.scale.set(capModelscale,capModelscale,capModelscale);


    ball.position.y = 50;
    ball.position.x = 0;
    ball.position.z = playerDistance * globalDirection;
    ball.castShadow = true;
    ball.receiveShadow = true;

    scene.add(ball);
    elements.push(ball);

    playedCaps = ball;

    if(elements.length > 10){
        var last = elements[0];
        scene.remove(last);
        elements.splice(0, 1);
    }
}


var power = 0,
    speedbar = 2,
    powerDir = speedbar,
    strengh = 6;


function setPower(){
    power += powerDir;

    if(power > 100){
        powerDir = -speedbar;
    }

    if(power < 0){
        powerDir = +speedbar;
    }

    $('.powerbar .bar').height(power+'%');
}



$(document).ready(function(){
    loadCollada();


});;var playerCamera;
var vlCamera;
var camera;
var playerCamPos = new THREE.Vector3( 10, 190, 170 );
var vlCamPos = new THREE.Vector3( 10, 190, -170 );

var VIEW_ANGLE = 75,
    ASPECT = WIDTH / HEIGHT,
    NEAR = 0.1,
    FAR = 10000;

function create_camera(){

    playerCamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    playerCamera.position.set(playerCamPos.x, playerCamPos.y, playerCamPos.z);
    playerCamera.lookAt(scene);
    scene.add(playerCamera);


    vlCamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    vlCamera.position.set(vlCamPos.x, vlCamPos.y, vlCamPos.z);
    vlCamera.lookAt(scene);
    scene.add(vlCamera);




    camera = playerCamera;
    camera.initialpos = playerCamPos;


    mouse = {x : 0, y : 0};

    document.addEventListener('mousemove', function(event){
        mouse.x	= (event.clientX / window.innerWidth ) - 0.5;
        mouse.y	= (event.clientY / window.innerHeight) - 0.5;
        camera.position.x += (mouse.x * 20 - camera.position.x) * (0.5*3) + camera.initialpos.x;
        camera.position.y += (mouse.y * 10 - camera.position.y) * (0.5*3) + camera.initialpos.y-10;
        camera.lookAt(lookatobj);
    }, false);
}

function change_camera(){
    if(camera == playerCamera){
        camera = vlCamera;
        camera.initialpos = vlCamPos;
        lookatobj = BottlePlayer.bottle;
        globalDirection = -1;

    }else{
        camera = playerCamera;
        camera.initialpos = playerCamPos;
        lookatobj = BottleViensla.bottle;
        globalDirection = 1;


    }
};


var BottleViensla = {

    initialize : function(){

//        this.bottle = new Physijs.CylinderMesh(
//            new THREE.CylinderGeometry(3, 5, 30, 32),
//            Physijs.createMaterial(
//                new THREE.MeshPhongMaterial({
//                    color: cyellow, ambient: 0xffffff, specular: 0xffffff, shininess: 250
//                })
//            ),
//            320, {friction : 0.1, restitution : 0.1}
//        );


        var bottle_material = Physijs.createMaterial(
//            new THREE.MeshLambertMaterial(bottle_mat.materials)
            new THREE.MeshPhongMaterial( {  color: cgreen, specular: 0x666666, ambient: 0x000000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.8, transparent: true, side:2 } )
        );
//        bottle_material.side = 2;
//        bottle_material.color.setHex( cgreen );

//        bottle_material.map = THREE.ImageUtils.loadTexture( 'images/caps2.jpg' );
        console.log(bottle_material);



        this.bottle = new Physijs.CylinderMesh(
            bottle_geo,
            bottle_material,
            320, {friction : 0.1, restitution : 0.1}
        );
        this.bottle.scale.set(10,10,10);

        this.bottle.castShadow = true;
        this.bottle.receiveShadow = true;

        BottleViensla.place({x:0, z:-92});
        BottleViensla.generateBottle();

    },
    place : function(axis){
        this.bottle.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2+18;
        this.bottle.position.x = axis.x;
        this.bottle.position.z = axis.z;
    },
    generateBottle : function(){
        scene.add(BottleViensla.bottle);
        BottleViensla.generateCaps();
    },
    generateCaps : function(){

        var caps_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial(mat_caps.materials)
        );
        caps_material.side = 2;

        caps_material.color.setHex( cgreen );

        this.bottlecaps = new Physijs.CylinderMesh(geo_caps, caps_material,  0.3);
        this.bottlecaps.castShadow = true;
        this.bottlecaps.receiveShadow = true;

        this.bottlecaps.scale.set(capModelscale,capModelscale,capModelscale);
        this.bottlecaps.rotation.x = Math.PI;

        this.bottlecaps.position.y = BottleViensla.bottle.position.y + 19;
        this.bottlecaps.position.x = BottleViensla.bottle.position.x;
        this.bottlecaps.position.z = BottleViensla.bottle.position.z;

        scene.add(BottleViensla.bottlecaps);

    }
}




var BottlePlayer = {

    initialize : function(){
//        this.bottle = new Physijs.CylinderMesh(
//            new THREE.CylinderGeometry(3, 5, 30, 32),
//            Physijs.createMaterial(
//                new THREE.MeshPhongMaterial({
//                    color: cblue, ambient: 0xffffff, specular: 0xffffff, shininess: 0
//                })
//            ),
//            320, {friction : 0.1, restitution : 0.1}
//        );


        var bottle_material = Physijs.createMaterial(
//            new THREE.MeshLambertMaterial(bottle_mat.materials)
        new THREE.MeshPhongMaterial( { color: cyellow, specular: 0x666666, ambient: 0x000000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.8, transparent: true, side:2 } )
        );
//        bottle_material.side = 2;
//        bottle_material.color.setHex( cyellow );
        this.bottle = new Physijs.CylinderMesh(
            bottle_geo,
            bottle_material,
            320, {friction : 0.1, restitution : 0.1}
        );
        this.bottle.scale.set(10,10,10);

        this.bottle.castShadow = true;
        this.bottle.receiveShadow = true;

        BottlePlayer.place({x:0, z:92});
        BottlePlayer.generateBottle();

    },
    place : function(axis){
        this.bottle.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2+18;
        this.bottle.position.x = axis.x;
        this.bottle.position.z = axis.z;
    },
    generateBottle : function(){
        scene.add(BottlePlayer.bottle);
        BottlePlayer.generateCaps();
    },
    generateCaps : function(){


        var caps_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial(mat_caps.materials)
        );
        caps_material.side = 2;

        caps_material.color.setHex( cyellow );

        this.bottlecaps = new Physijs.CylinderMesh(geo_caps, caps_material, 0.3);
        this.bottlecaps.castShadow = true;
        this.bottlecaps.receiveShadow = true;

        this.bottlecaps.scale.set(capModelscale,capModelscale,capModelscale);
        this.bottlecaps.rotation.x = Math.PI;

        this.bottlecaps.position.y = BottlePlayer.bottle.position.y + 19;
        this.bottlecaps.position.x = BottlePlayer.bottle.position.x;
        this.bottlecaps.position.z = BottlePlayer.bottle.position.z;

        scene.add(BottlePlayer.bottlecaps);

    }
}


// AXIS
function buildAxes( length ) {
    var axes = new THREE.Object3D();
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
    return axes;
}

function buildAxis( src, dst, colorHex, dashed ) {
    var geom = new THREE.Geometry(),
        mat;

    if(dashed) {
        mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
    } else {
        mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
    }

    geom.vertices.push( src.clone() );
    geom.vertices.push( dst.clone() );
    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

    var axis = new THREE.Line( geom, mat, THREE.LinePieces );

    return axis;

}


document.addEventListener(
    'keydown',
    function( ev ) {
        console.log(ev.keyCode);
        switch( ev.keyCode ) {
            case 37:
                // Left


                break;

            case 39:
                // Right

                break;

            case 38:
                // Up

                break;

            case 40:
                // Down
                break;

            case 32:
                // space
                create_caps();
                break;

            case 67:
//                lookatobj = ball;
                break;

            case 86:
                console.log('bottlecaps vl')
                lookatobj = BottleViensla.bottle;
                break;

            case 66:
                lookatobj = scene;
                break;

            case 65 :
                if(axes.presence){
                    axes.traverse( function ( object ) { object.visible = false; } );
                    axes.presence = false;
                }else{
                    axes.traverse( function ( object ) { object.visible = true; } );
                    axes.presence = true;
                }
            break;

            case 13:
                change_camera();
                break;
        }
    }
);
;var currentPlayer = 'player';


function change_player(){







};
planeWIDTH = 280;
planeHEIGHT = 500;


var tableSurfaceDim = [100, 2, 20];
var tablefootSurfaceDim = [80, 40, 2];
var level, _floor, _tablefoot, _table;
function create_table(){


    //Set Level group
    level = new Physijs.BoxMesh(
        new THREE.CubeGeometry( 5, 1, .5 ),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: cblue
            })
        ), 0
    );
    level.position.x = 0;
    level.position.y = 0;
    level.position.z = 0;
    level.castShadow = true;
    level.receiveShadow = true;


    //Add floor to level
    _floor = new Physijs.BoxMesh(
        new THREE.CubeGeometry(planeWIDTH, planeHEIGHT, 35),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: cred
            })
        ), 0);
    _floor.rotation.x = Math.PI/2;
    _floor.position.x = 0;
    _floor.position.y = 1;
    _floor.position.z = 0;
    _floor.castShadow = true;
    _floor.receiveShadow = true;



    level.add(_floor);


    //Add table foots
    _tablefoot = new Physijs.BoxMesh(
        new THREE.CubeGeometry(tablefootSurfaceDim[0], tablefootSurfaceDim[1], tablefootSurfaceDim[2]),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: cblue
            })
        ), 0);
    _tablefoot.position.x = 0;
    _tablefoot.position.y = tablefootSurfaceDim[1];
    _tablefoot.position.z = -90;

    _tablefoot.castShadow = true;
    _tablefoot.receiveShadow = true;

    level.add(_tablefoot);


    _tablefoot = new Physijs.BoxMesh(
        new THREE.CubeGeometry(tablefootSurfaceDim[0], tablefootSurfaceDim[1], tablefootSurfaceDim[2]),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: cgreen
            })
        ), 0);
    _tablefoot.position.x = 0;
    _tablefoot.position.y = tablefootSurfaceDim[1];
    _tablefoot.position.z = 90;
    _tablefoot.castShadow = true;
    _tablefoot.receiveShadow = true;

    level.add(_tablefoot);

    //Add table

    _table = new Physijs.BoxMesh(
        new THREE.CubeGeometry(tableSurfaceDim[0], tableSurfaceDim[1], tableSurfaceDim[2]),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: 0xffffff
            })
        ), 0);
    _table.position.x = 0;
    _table.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2 ;
    _table.position.z = -90;
    _table.castShadow = true;
    _table.receiveShadow = true;
    level.add(_table);

    _table = new Physijs.BoxMesh(
        new THREE.CubeGeometry(tableSurfaceDim[0], tableSurfaceDim[1], tableSurfaceDim[2]),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: 0xffffff
            })
        ), 0);
    _table.position.x = 0;
    _table.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2 ;
    _table.position.z = 90;
    _table.castShadow = true;
    _table.receiveShadow = true;
    level.add(_table);

    scene.add(level);




    // SKYDOME

    var vertexShader = document.getElementById( 'vertexShader' ).textContent;
    var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
    var uniforms = {
        topColor: 	 { type: "c", value: new THREE.Color( 0x0077ff ) },
        bottomColor: { type: "c", value: new THREE.Color( 0xffffff ) },
        offset:		 { type: "f", value: 33 },
        exponent:	 { type: "f", value: 0.6 }
    }
    uniforms.topColor.value.copy( hemiLight.color );

    scene.fog.color.copy( uniforms.bottomColor.value );

    var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
    var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

    var sky = new THREE.Mesh( skyGeo, skyMat );
    scene.add( sky );
}


;function create_lights(){
    var frontLight	= new THREE.DirectionalLight(0xffffff, 0.7);
    frontLight.castShadow = true;
    frontLight.shadowDarkness = .1;
    frontLight.shadowBias = -.0001;
    frontLight.shadowCameraNear = 1;
    frontLight.shadowMapWidth = 2048;
    frontLight.shadowMapHeight = 2048;
    frontLight.shadowCameraLeft = planeWIDTH/2;
    frontLight.shadowCameraTop = - planeHEIGHT/2;
    frontLight.shadowCameraRight = - planeWIDTH/2;
    frontLight.shadowCameraBottom = planeHEIGHT/2;


    frontLight.position.set(0, 100, 80);

    scene.add( frontLight );

    var backLight	= new THREE.DirectionalLight(0xffffff, 0.7);

    backLight.castShadow = true;
    backLight.shadowDarkness = .1;
    backLight.shadowBias = -.0001;
    backLight.shadowCameraNear = 1;
    backLight.shadowMapWidth = 2048;
    backLight.shadowMapHeight = 2048;
    backLight.shadowCameraLeft = planeWIDTH/2;
    backLight.shadowCameraTop = - planeHEIGHT/2;
    backLight.shadowCameraRight = - planeWIDTH/2;
    backLight.shadowCameraBottom = planeHEIGHT/2;


    backLight.position.set(0, 100, -80);

    scene.add( backLight );


    var rightLight	= new THREE.DirectionalLight(0xfefefe, 0.1);

    rightLight.castShadow = true;
    rightLight.shadowDarkness = .05;
    rightLight.shadowBias = -.0001;
    rightLight.shadowCameraNear = 1;
    rightLight.shadowMapWidth = 2048;
    rightLight.shadowMapHeight = 2048;
    rightLight.shadowCameraLeft = planeWIDTH/2;
    rightLight.shadowCameraTop = - planeHEIGHT/2;
    rightLight.shadowCameraRight = - planeWIDTH/2;
    rightLight.shadowCameraBottom = planeHEIGHT/2;


    rightLight.position.set(80, 40, 30);

//    scene.add( rightLight );


    var leftLight	= new THREE.DirectionalLight(0xfefefe, 0.1);

    leftLight.castShadow = true;
    leftLight.shadowDarkness = .05;
    leftLight.shadowBias = -.0001;
    leftLight.shadowCameraNear = 1;
    leftLight.shadowMapWidth = 2048;
    leftLight.shadowMapHeight = 2048;
    leftLight.shadowCameraLeft = planeWIDTH/2;
    leftLight.shadowCameraTop = - planeHEIGHT/2;
    leftLight.shadowCameraRight = - planeWIDTH/2;
    leftLight.shadowCameraBottom = planeHEIGHT/2;


    leftLight.position.set(-100, 70, -10);

//    scene.add( leftLight );
//
//
//    // LIGHTS
    scene.add( new THREE.AmbientLight( 0x000000 ) );
//
//
//
//    var directionalLight = new THREE.DirectionalLight(/*Math.random() * 0xffffff*/0xeeeeee );
//    directionalLight.position.set( .2, -1, .2 );
//    directionalLight.position.normalize();
//    scene.add( directionalLight );
//
    pointLight = new THREE.PointLight( 0xffffff, .6 );
    scene.add( pointLight );

// LIGHTS


    hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
    hemiLight.color.setHSL( 0.6, 1, 0.6 );
    hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
    hemiLight.position.set( 0, 500, 0 );
    scene.add( hemiLight );

//    var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
//    dirLight.color.setHSL( 0.1, 1, 0.95 );
//    dirLight.position.set( -1, 90, 1 );
//    dirLight.position.multiplyScalar( 50 );
//    scene.add( dirLight );
//
//    dirLight.castShadow = true;
//
//    dirLight.shadowMapWidth = 2048;
//    dirLight.shadowMapHeight = 2048;
//
//    var d = planeHEIGHT/2;
//
//    dirLight.shadowCameraLeft = -d;
//    dirLight.shadowCameraRight = d;
//    dirLight.shadowCameraTop = d;
//    dirLight.shadowCameraBottom = -d;
//
//    dirLight.shadowCameraFar = 3500;
//    dirLight.shadowCameraNear = 1;
//    dirLight.shadowBias = -0.0001;
//    dirLight.shadowDarkness = 0.35;




}























var pointLight;

var light1, light2, light3, light4, light5,light6,light7,light8,light9,light10,light11,light12;
function addFloatingLights(){
    var sphere = new THREE.SphereGeometry( 0.5, 16, 8 );

    light1 = new THREE.PointLight( 0xff0040, 2, 50 );
    light1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
    scene.add( light1 );

    light2 = new THREE.PointLight( 0x0040ff, 2, 50 );
    light2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
    scene.add( light2 );

    light3 = new THREE.PointLight( 0x80ff80, 2, 50 );
    light3.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x80ff80 } ) ) );
    scene.add( light3 );

    light4 = new THREE.PointLight( 0xffaa00, 2, 50 );
    light4.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
    scene.add( light4 );

    light5 = new THREE.PointLight( 0xff0040, 2, 50 );
    light5.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
    scene.add( light5 );

    light6 = new THREE.PointLight( 0x0040ff, 2, 50 );
    light6.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
    scene.add( light6 );

    light7 = new THREE.PointLight( 0x80ff80, 2, 50 );
    light7.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x80ff80 } ) ) );
    scene.add( light7 );

    light8 = new THREE.PointLight( 0xffaa00, 2, 50 );
    light8.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
    scene.add( light8 );

    light9 = new THREE.PointLight( 0xff0040, 2, 50 );
    light9.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
    scene.add( light9 );

    light10 = new THREE.PointLight( 0x0040ff, 2, 50 );
    light10.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
    scene.add( light10 );

    light11 = new THREE.PointLight( 0x80ff80, 2, 50 );
    light11.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x80ff80 } ) ) );
    scene.add( light11 );

    light12 = new THREE.PointLight( 0xffaa00, 2, 50 );
    light12.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
    scene.add( light12 );
}

function animateFloatingLights(time){
    light1.position.x = Math.sin( time * 0.7 ) * 50;
    light1.position.y = Math.cos( time * 0.5 ) * 50 + 100;
    light1.position.z = Math.cos( time * 0.3 ) * 50;

    light2.position.x = Math.cos( time * 0.3 ) * 50;
    light2.position.y = Math.sin( time * 0.5 ) * 50 + 100;
    light2.position.z = Math.sin( time * 0.7 ) * 50;

    light3.position.x = Math.sin( time * 0.7 ) * 50;
    light3.position.y = Math.cos( time * 0.3 ) * 50 + 100;
    light3.position.z = Math.sin( time * 0.5 ) * 50;

    light4.position.x = Math.sin( time * 0.3 ) * 50;
    light4.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light4.position.z = Math.sin( time * 0.5 ) * 50;

    light5.position.x = Math.sin( time * 0.3 ) * 50;
    light5.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light5.position.z = Math.sin( time * 0.5 ) * 50;

    light6.position.x = Math.sin( time * 0.3 ) * 50;
    light6.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light6.position.z = Math.sin( time * 0.5 ) * 50;

    light7.position.x = Math.sin( time * 0.3 ) * 50;
    light7.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light7.position.z = Math.sin( time * 0.5 ) * 50;

    light8.position.x = Math.sin( time * 0.3 ) * 50;
    light8.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light8.position.z = Math.sin( time * 0.5 ) * 50;

    light9.position.x = Math.sin( time * 0.3 ) * 50;
    light9.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light9.position.z = Math.sin( time * 0.5 ) * 50;

    light10.position.x = Math.sin( time * 0.3 ) * 50;
    light10.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light10.position.z = Math.sin( time * 0.5 ) * 50;

    light11.position.x = Math.sin( time * 0.3 ) * 50;
    light11.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light11.position.z = Math.sin( time * 0.5 ) * 50;

    light12.position.x = Math.sin( time * 0.3 ) * 50;
    light12.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light12.position.z = Math.sin( time * 0.5 ) * 50;

}