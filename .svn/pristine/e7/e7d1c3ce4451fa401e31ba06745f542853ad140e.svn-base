var container, scene, renderer, camera, light, ball, plane, bottle, bottlecaps, axes, initEventHandling, initScene;
var WIDTH, HEIGHT, VIEW_ANGLE, ASPECT, NEAR, FAR, planeWIDTH, planeHEIGHT;

var elements = [], playedCaps = null, mouse_position = new THREE.Vector3, block_offset = new THREE.Vector3, _i, _v3 = new THREE.Vector3, intersect_plane, lookatobj, pilone, mouse,
    mouse3D = new THREE.Vector3;

var _nullVector = new THREE.Vector3(0,0,0), DCMP  = new THREE.Vector3(0,0,0);

var onRenderFcts= [];

var lastTimeMsec= null;

var capsYpos = 30;

var movingCaps = null;

var clock = new THREE.Clock(), dir, distance;

var holdingDown = false;


//var strength = 5;


Physijs.scripts.worker = '/js/physijs/physijs_worker.js';
Physijs.scripts.ammo = 'ammo.js';

container = document.querySelector('.viewport');

WIDTH = window.innerWidth;
HEIGHT = window.innerHeight;

VIEW_ANGLE = 75;
ASPECT = WIDTH / HEIGHT;
NEAR = 0.1;
FAR = 10000;



planeWIDTH = 300;
planeHEIGHT = 300;


var playerDistance = 40;


var y_launcher = 0;
var y_launcher_inc = 0.2;
var table_material = Physijs.createMaterial(
    new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/wood.jpg' ), ambient: 0xFFFFFF, opacity: 0.5, transparent: true }),
    .9, // high friction
    .2 // low restitution
);
table_material.map.wrapS = table_material.map.wrapT = THREE.RepeatWrapping;
table_material.map.repeat.set( 5, 5 );




var caps_geometry = new THREE.CylinderGeometry(4, 3, 1.2, 32),

    caps_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
            color: 0xff0000
        }), 0.4, 0.8),

    bottlecaps_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
            color: 0x00ff00
        }), 0.4, 0.8),

    maxicaps_material = '';


initScene = function() {

    scene = new Physijs.Scene();

    scene.setGravity(new THREE.Vector3( 0, -80, 0 ));

    renderer = new THREE.WebGLRenderer({
        antialias: true
    });

    renderer.setSize(WIDTH, HEIGHT);
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFShadowMap;
    renderer.shadowMapAutoUpdate = true;
    container.appendChild(renderer.domElement);

    create_camera();

    create_lights();

    create_plane();

    // ADD AXES *******************************************************
    axes = buildAxes( 1000 );
    axes.presence = false;
    axes.traverse( function ( object ) { object.visible = false; } );
    scene.add(axes);

    create_bottle(0);

    create_caps();

//    create_pilone();




    scene.simulate();

    render();

    initEventHandling();


    scene.addEventListener('update', function() {

        if(playedCaps){
            playedCaps.position.copy(DCMP);
        }

        if(holdingDown){
            setPower();
            console.log(power);
        }

        scene.simulate(undefined, 2);

    });



}





initEventHandling = (function() {
    var projector, ray, intersection,
        handleMouseDown, handleMouseMove, handleMouseUp,
        launchVector = new THREE.Vector3,
        _vector = new THREE.Vector3;


    handleMouseDown = function( evt ) {

        if(!playedCaps) return;

        holdingDown = true;

        launchVector.set(1,-3, -100);


        power = 0;

    };

    handleMouseMove = function( evt ) {


        if(!holdingDown){
            mouse3D.set(
                ( evt.clientX / window.innerWidth ) * 2 - 1,
                - ( evt.clientY / window.innerHeight ) * 2 + 1,
                1 );

            mouse3D.unproject(camera);

            dir = mouse3D.sub( camera.position ).normalize();

            distance = - camera.position.z / dir.z;

            DCMP = camera.position.clone().add( dir.multiplyScalar(distance/2) );

            DCMP.z = playerDistance;
        }


    };

    handleMouseUp = function( evt ) {

        if(!playedCaps) return;

        holdingDown = false;

        playedCaps.__dirtyPosition = true;

        _vector.set( 1, 1, 1 );

        playedCaps.setAngularFactor( _vector );

        playedCaps.setLinearFactor( _vector );


        launchVector.set(1,-3, -power);
        playedCaps.setLinearVelocity( launchVector );

        playedCaps.position.copy(DCMP);

        playedCaps = null;

    };

    return function() {
        renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
        renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
        renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
    };
})();



$(document).ready(function(){
    initScene();

});



function render() {

//    if (ball.position.y <= -50 || ball.position.z <= -500) {
//        create_caps();
//    }
//
//    if(ball.position.z <= -100){
//        create_caps();
//    }

//    if(ball.position.y <= 10){
//        ball.setAngularFactor( _nullVector );
//        ball.setLinearFactor( _nullVector );
//    }

    if(bottlecaps.position.y <= bottle.position.y){
        create_bottlecaps();
    }

    camera.lookAt(lookatobj.position);

    renderer.render(scene, camera);
    requestAnimationFrame(render);
}



function create_caps(){



    ball = new Physijs.CylinderMesh(caps_geometry, caps_material, 20, {friction : 0, restitution : 0.8});


    ball.rotation.x = Math.PI;

    ball.position.y = 50;
    ball.position.x = 0;
    ball.position.z = playerDistance;
    ball.castShadow = true;
    ball.receiveShadow = true;

    scene.add(ball);

    elements.push(ball);

    playedCaps = ball;




    if(elements.length > 10){
        var last = elements[0];
        scene.remove(last);
        elements.splice(0, 1);
    }
}


var power = 0,
    powerDir = 1;


function setPower(){
    power += powerDir;

    if(power > 250){
        powerDir = -3;
    }
    if(power < 50){
        powerDir = +3;
    }

    $('.powerbar').width(power/2.5+'%');

}