/* colors */
var cblue = 0x67AAC1;
var cyellow = 0xF7D443;
var cgreen = 0x78AD60;
var cred = 0xC1676A;

var ptpgrey = 0x595556;
var ptpyellow = 0xfedc2a;



var container, scene, renderer, light, ball, plane, bottle, bottlecaps, axes, initEventHandling, initScene;
var WIDTH, HEIGHT, planeWIDTH, planeHEIGHT;

var elements = [], playedCaps = null, mouse_position = new THREE.Vector3, block_offset = new THREE.Vector3, _i, _v3 = new THREE.Vector3, intersect_plane, lookatobj, pilone, mouse,
    mouse3D = new THREE.Vector3;

var _nullVector = new THREE.Vector3(0,0,0), DCMP  = new THREE.Vector3(0,0,0);
var _natVector = new THREE.Vector3(1,1,1);

var onRenderFcts= [];

var lastTimeMsec= null;

var capsYpos = 80;


var movingCaps = null;

var clock = new THREE.Clock(), dir, distance;

var holdingDown = false;

var discImg = THREE.ImageUtils.loadTexture( "images/caps2.jpg" );
var discMat = new THREE.MeshLambertMaterial( { map: discImg } );


var discParticules, discGeo = new THREE.Geometry();


Physijs.scripts.worker = '/js/physijs/physijs_worker.js';
Physijs.scripts.ammo = 'ammo.js';

container = document.querySelector('.viewport');

WIDTH = window.innerWidth;
HEIGHT = window.innerHeight;



var playerDistance = 85;
var globalDirection = 1;

var capsDae;
var capsMesh;

var capModelscale = 1.6;

var geo_caps, mat_caps, bottle_geo, bottle_mat;

var $plpart, $vlpart, plscore = 0, vlscore = 0;

var texture, mat;

var sticker_geo;

var composer;

var testPly = {
    geo : '',
    mat : ''
};


function loadBottleTools(){
    var loader = new THREE.JSONLoader();



    loader.load( 'model/chimey/chimey.json', function ( cap_geometry, cap_materials ) {

        loader.load( 'model/sticker/sticker.json', function ( sticker_geometry ) {
            sticker_geo = sticker_geometry;
        });
        loader.load( 'model/bottle/bottle_chimey.json', function ( bottle_geometry, bottle_materials ) {

            bottle_geo = bottle_geometry;


            var bottle_material = bottle_materials[ 0 ];
            bottle_material.side = 2;
            bottle_material.map.anisotropy=0;
            bottle_material.shininess = 0;
            bottle_material.shading = 0;
            bottle_material.reflectivity = 0;
            bottle_material.ambient.setHex(0xffffff);
            bottle_material.color.setHex(0xffffff);

            bottle_mat = new THREE.MeshFaceMaterial( bottle_materials );

            geo_caps = cap_geometry;

            var cap_material = cap_materials[ 0 ];
            cap_material.side = 2;
            cap_material.map.anisotropy=0;
            mat_caps = new THREE.MeshFaceMaterial( cap_materials );


            initScene();
        });
    });
}





var caps_geometry;
caps_geometry = new THREE.CylinderGeometry(4, 3, 1.2, 32);

var caps_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
            color: cred
        }), 0.4, 0.8);



var bottlecaps_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
            color: cgreen
        }), 0.4, 0.8),

initScene = function() {



    scene = new Physijs.Scene();

    scene.setGravity(new THREE.Vector3( 0, -80, 0 ));

    scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

    renderer = new THREE.WebGLRenderer({
        antialias: true
    });

    renderer.setSize(WIDTH, HEIGHT);
    renderer.shadowMapEnabled = true;
    renderer.shadowMapSoft = true;
    renderer.shadowMapType = THREE.PCFShadowMap;
    renderer.shadowMapAutoUpdate = true;

    renderer.gammaInput = true;
    renderer.gammaOutput = true;

    renderer.setClearColor( scene.fog.color, 1 );
    container.appendChild(renderer.domElement);

    create_camera();

    create_lights();

    create_table();

    // ADD AXES *******************************************************
    axes = buildAxes( 1000 );
    axes.presence = false;
    axes.traverse( function ( object ) { object.visible = false; } );
    scene.add(axes);

    Viensla.initialize();
    Player.initialize();

    lookatobj = Viensla.bottle;

    scene.simulate();

    initEventHandling();

    spotCreator.create();



    composer = new THREE.EffectComposer( renderer );
    composer.addPass( new THREE.RenderPass( scene, camera ) );
    var hblur = new THREE.ShaderPass( THREE.HorizontalBlurShader );



    composer.addPass( hblur );
    var vblur = new THREE.ShaderPass( THREE.VerticalBlurShader );

// set this shader pass to render to screen so we can see the effects
    vblur.renderToScreen = true;
    composer.addPass( vblur );


    render();

    scene.addEventListener('update', function() {

        if(playedCaps && Player.isPlaying){
            playedCaps.position.copy(DCMP);
        }

        if(holdingDown){
            setPower();
        }

        scene.simulate(undefined, 2);

    });
};







function render() {

    if(
        (Viensla.bottlecaps.position.y <= Viensla.bottle.position.y
        || Viensla.bottlecaps.position.y > Viensla.bottle.position.y + 20
        || Viensla.bottlecaps.position.x > Viensla.bottle.position.x + 5
        || Viensla.bottlecaps.position.x < Viensla.bottle.position.x - 5
        || Viensla.bottlecaps.position.z > Viensla.bottle.position.z + 5
        || Viensla.bottlecaps.position.z < Viensla.bottle.position.z - 5)

        && Viensla.bottlecaps.collided){

        Viensla.bottlecaps.collided = false;

        Party.plcaps();


    }



    if( (Player.bottlecaps.position.y <= Player.bottle.position.y
        || Player.bottlecaps.position.y > Player.bottle.position.y + 20
        || Player.bottlecaps.position.x > Player.bottle.position.x + 5
        || Player.bottlecaps.position.x < Player.bottle.position.x - 5
        || Player.bottlecaps.position.z > Player.bottle.position.z + 5
        || Player.bottlecaps.position.z < Player.bottle.position.z - 5)
        && Player.bottlecaps.collided){


        Player.bottlecaps.collided = false;

        Party.vlcaps();

    }

    camera.lookAt(lookatobj.position);

    spotCreator.draw();


    var time = Date.now() * 0.0005;

//    animateFloatingLights(time);

    pointLight.position.x = Math.sin( time ) * 3000;
    pointLight.position.y = 600;
    pointLight.position.z = Math.cos( time ) * 3000;


    renderer.render(scene, camera);
    if(Player.drunked > 10){

        composer.render();
        camera.position.x += (Math.sin( time*10 )*2 - camera.position.x) * (0.5*3) + camera.initialpos.x;
        camera.position.y += (Math.cos( time*10 )*2 - camera.position.y) * (0.5*3) + camera.initialpos.y-10;




    }

//    camera.position.z += Math.sin( time )/10;



//    camera.position.y += Math.sin( time );
//    camera.position.z += Math.cos( time );

    requestAnimationFrame(render);


}



var discTopVector =  new THREE.Vector3(1,20,1);

var spotCreator = {
    obj : null,
    els : [],
    nbDisc : 0,
    create : function(){
        discParticules = new THREE.PointCloud( discGeo, discMat );
    },
    draw : function(){

        if(!this.obj) return;
//
//        if(spotCreator.nbDisc%2 == 0) {
//            this.nbDisc++;
//            return;
//        }

        if(spotCreator.nbDisc > 80){
            spotCreator.obj = null;
            spotCreator.nbDisc = 0;
            spotCreator.els = [];
            return;
        }

        var disc = new Physijs.BoxMesh(
            new THREE.SphereGeometry( Math.random(), 5, 16 ),
            discMat
        );

        disc.position.x = Viensla.bottle.position.x;
        disc.position.y = Player.bottle.position.y + 20;
        disc.position.z = Viensla.bottle.position.z;
//        disc.position.x = spotCreator.obj.position.x;
//        disc.position.y = spotCreator.obj.position.y;
//        disc.position.z = spotCreator.obj.position.z;

//        disc.__dirtyPosition = true;

        discTopVector.set(Math.random()*10, Math.random()*40, Math.random()*10);

        setTimeout(function(){
//            scene.remove(disc);
        }, 5000);

//        scene.add(disc);

        disc.setLinearVelocity(discTopVector);


        this.nbDisc++;


    }
};




$(document).ready(function(){
    $plpart = $('.pl-part');
    $vlpart = $('.vl-part');

    loadBottleTools();

    window.addEventListener( 'resize', onWindowResize, false );

    $('#party').click(function(){
        Party.create();
    });

    $('#mute').click(function(){
        Sounds.mute = !Sounds.mute;
    });

    for(var i =0; i < Party.capsPerTurn; i++){
        $('.capsstock').append('<span></span>');
    }

    $plpart.find('.capsstock span').click(function(){
        if(!Viensla.isPlaying){
            Party.plplay();
        }
    });

});



function onWindowResize( event ) {

    renderer.setSize( window.innerWidth, window.innerHeight );

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

};var playerCamera;
var vlCamera;
var camera;
var playerCamPos = new THREE.Vector3( 0, 240, 165 );
var vlCamPos = new THREE.Vector3( 0, 190, -170 );

var VIEW_ANGLE = 75,
    ASPECT = WIDTH / HEIGHT,
    NEAR = 0.1,
    FAR = 10000;

function create_camera(){

    playerCamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    playerCamera.position.set(playerCamPos.x, playerCamPos.y, playerCamPos.z);
    playerCamera.lookAt(scene);
    scene.add(playerCamera);


    vlCamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    vlCamera.position.set(vlCamPos.x, vlCamPos.y, vlCamPos.z);
    vlCamera.lookAt(scene);
    scene.add(vlCamera);




    camera = playerCamera;
    camera.initialpos = playerCamPos;

    camera.focalLength = 25;
    camera.frameSize = 32;
//    camera.setLens(camera.focalLength, camera.frameSize);

    mouse = {x : 0, y : 0};

    document.addEventListener('mousemove', function(event){
        mouse.x	= (event.clientX / window.innerWidth ) - 0.5;
        mouse.y	= (event.clientY / window.innerHeight) - 0.5;

        if(Player.drunked < 11){
            camera.position.x += (mouse.x * 20 - camera.position.x) * (0.5*3) + camera.initialpos.x;
            camera.position.y += (mouse.y * 10 - camera.position.y) * (0.5*3) + camera.initialpos.y-10;
        }
        camera.lookAt(lookatobj);
    }, false);
}

function change_camera(){
    if(camera == playerCamera){
        camera = vlCamera;
        camera.initialpos = vlCamPos;
        lookatobj = Player.bottle;
        globalDirection = -1;

    }else{
        camera = playerCamera;
        camera.initialpos = playerCamPos;
        lookatobj = Viensla.bottle;
        globalDirection = 1;


    }
};


capCollision = function ( collided, linearVelocity, angularVelocity, other ){

    var capPlayed = this;
    capPlayed.collisions++;

    if(capPlayed.floating) return;


    var collision = collided.name;


    switch(collision){
        case 'level':
            if(!Sounds.mute) Sounds.simpletap2.play();
            break;
        case 'tapis':
            if(!Sounds.mute) Sounds.simpletap1.play();
            break;
        case 'floor':
            if(!Sounds.mute) Sounds.simpletap3.play();
            break;
        case 'vlCap':

            if(capPlayed.name == 'player'){
                collided.collided = true;
            }

            if(!Sounds.mute) Sounds.capcap.play();

            break;
        case 'plCap':

            if(capPlayed.name == 'viensla'){
                collided.collided = true;
            }

            if(!Sounds.mute) Sounds.pschit1.play();

            break;
        case 'vlBottle':
            if(!Sounds.mute) Sounds.clink.play();
            break;
        case 'plBottle':
            if(!Sounds.mute) Sounds.pschit1.play();
            break;
        case '':
            console.log('Unamed hit !');
            break;
    }



    if(collision == 'vlCap'){
        collided.__dirtyPosition = true;
    }



};




function create_caps(who){
    var randomCaps = Math.random() > 0.8;
    var mass = randomCaps ? 4 : 2;

    if(typeof who == 'undefined'){
        who = 'pl';
    }



    var caps_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial(mat_caps.materials)
    );

    caps_material.side = 2;

    if(randomCaps){
        caps_material.color.setHex( cred );
    }else{
        caps_material.color.setHex( cblue );
    }

    mat_caps.side = 2;

    ball = new Physijs.CylinderMesh(geo_caps, mat_caps, mass, {friction : 0, restitution : 0.8});

    ball.scale.set(capModelscale,capModelscale,capModelscale);


    ball.collisions = 0;
    ball.addEventListener( 'collision', capCollision );



    ball.position.y = 50;
    ball.position.x = 0;
    ball.position.z = playerDistance * globalDirection;
    ball.castShadow = true;
    ball.receiveShadow = true;

    scene.add(ball);
    elements.push(ball);

    playedCaps = ball;

    playedCaps.floating = true;

    playedCaps.name = who == 'vl' ?  'viensla' : 'player';


    if(elements.length > 10){
        var last = elements[0];
        scene.remove(last);
        elements.splice(0, 1);
    }

    if(!Sounds.mute) Sounds.pschit1.play();
}





var power = 0,
    speedbar = 2,
    powerDir = speedbar,
    strengh = 6;


function setPower(){
    power += powerDir;

    if(power > 100){
        powerDir = -speedbar;
    }

    if(power < 0){
        powerDir = +speedbar;
    }

    $('.powerbar .bar').height(power+'%');
}






initEventHandling = (function() {
    var projector, ray, intersection,
        handleMouseDown, handleMouseMove, handleMouseUp,
        launchVector = new THREE.Vector3,
        _vector = new THREE.Vector3,
        _angVector = new THREE.Vector3;


    handleMouseDown = function( evt ) {

        if(!playedCaps) return;

        holdingDown = true;

        launchVector.set(1,-3, -100);

        power = 0;
        $('.powerbar').fadeIn();
    };

    handleMouseMove = function( evt ) {
        var mouseX = evt.clientX,
            mouseY = evt.clientY;


        $('.powerbar').css({left:mouseX+50, top:mouseY-50});


        if(!playedCaps) return;
//        if(!holdingDown){
        mouse3D.set(
            ( mouseX / window.innerWidth ) * 2 - 1,
            - ( mouseY / window.innerHeight ) * 2 + 1,
            1 );

        mouse3D.unproject(camera);


        dir = mouse3D.sub( camera.position ).normalize();

        distance = - camera.position.z / dir.z;

        DCMP = camera.position.clone().add( dir.multiplyScalar(distance/2) );

        DCMP.z = playerDistance*globalDirection;
//        }



    };

    handleMouseUp = function( evt ) {

        if(!playedCaps) return;



        holdingDown = false;

        playedCaps.__dirtyPosition = true;
        playedCaps.floating = false;

        _vector.set( 1, 1, 1 );
        _angVector.set( Math.random()*10, Math.random()*10, Math.random()*20);
        playedCaps.setAngularFactor( _vector );

        playedCaps.setLinearFactor( _vector );
        launchVector.set(1,-3, -power*strengh*globalDirection);
        playedCaps.setLinearVelocity( launchVector );
        playedCaps.setAngularVelocity( _angVector );

        playedCaps.position.copy(DCMP);

        playedCaps = null;

        power = 0;

        $('.powerbar').fadeOut();

        Player.launched++;
        Player.totalLaunched++;

        if(Player.launched == Party.capsPerTurn){



            setTimeout(function(){
                console.log('viens la attack');
                Viensla.launched = 0;
                Player.isPlaying = false;
                Party.vlplay();
            }, 3000);

        }

    };

    return function() {
        renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
        renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
        renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
    };
})();
;var timeoutRobot;

var Party = {
    isPlaying : false,
    capsPerTurn : 3,
    lives : 100,
    create : function(){
        this.isPlaying = true;
        Viensla.score = Player.score = Viensla.launched = Player.launched = 0;
        Viensla.lives = Player.lives = Party.lives;


        this.plplay();

        Viensla.isPlaying = false;
        Player.isPlaying = true;

        this.setLife();

        $('#party').fadeOut();

        $('.capsstock').fadeIn();


    },
    vlplay : function(){

        if(this.isPlaying){
            if(Viensla.launched < Party.capsPerTurn && !Player.isPlaying){

                $vlpart.find('.capsstock span').eq(Viensla.launched).hide();

                Viensla.isPlaying = true;
                Player.isPlaying = false;
                Viensla.launchCaps();

                timeoutRobot = setTimeout(function(){
                    Party.vlplay();
                }, 4000);



            }else{
                clearTimeout(timeoutRobot);
                Player.isPlaying = true;
                Player.launched = 0;
                Viensla.isPlaying = false;
                console.log('Viens la no more caps !');
                this.resetStocks();
            }
        }


    },
    plplay : function(){
        if(this.isPlaying){
            if(Player.launched < Party.capsPerTurn && !Viensla.isPlaying){
                $plpart.find('.capsstock span').eq(Player.launched).hide();

                clearTimeout(timeoutRobot);

                globalDirection = 1;
                create_caps('pl');


                Player.isPlaying = true;
                Viensla.isPlaying = false;


            }else{

                Player.isPlaying = false;

                console.log('Player no more caps !');

                Viensla.launched = 0;

                Party.vlplay();

            }
        }
    },

    vlcaps : function(){
        if(this.isPlaying){

            Viensla.score++;

            Player.drunked++;

            Player.lives -= Math.round((10 + 6 - Viensla.launched*2));

            clearTimeout(timeoutRobot);



            Viensla.isPlaying = false;

            capsm();

            Party.resetStocks();


            $vlpart.find('.score').text(Viensla.score);

            setTimeout(function(){

                Player.isPlaying = true;
                Player.launched = 0;
                Viensla.isPlaying = false;

                Player.generateCaps();
                Party.resetStocks();


            }, 1000);
            Party.setLife();

        }
    },


    plcaps : function(){
        if(this.isPlaying){
            Player.score++;
            Viensla.lives -= Math.round((10 + 6 - Player.launched*2));

            Player.isPlaying = false;

            capsm();

            $plpart.find('.score').text(Player.score);


            Party.resetStocks();

            setTimeout(function(){

                Viensla.generateCaps();
                Party.vlplay();

            }, 1000);

            Party.setLife();
        }

    },

    resetStocks : function(){
        if(this.isPlaying){
            $('.capsstock span').show();
            Viensla.launched = 0;
            Player.launched = 0;
        }

    },

    setLife : function(){
        if(this.isPlaying){
            var pctPlLife = Math.round(Player.lives / Party.lives * 100);
            var pctVlLife = Math.round(Viensla.lives / Party.lives * 100);

            $plpart.find('.life').height(pctPlLife+"%");
            $vlpart.find('.life').height(pctVlLife+"%");

            if(pctPlLife <= 0 || pctVlLife <= 0){
                Party.isPlaying = false;
                console.log('PARTY OVER');


                $('#party').fadeIn();






            }
        }
    }

}


function capsm(){

    $('#caps-m').show();
    setTimeout(function(){
        $('#caps-m').hide();
    }, 1000);

    if(!Sounds.mute) Sounds.pschit2.play();

};
planeWIDTH = 280;
planeHEIGHT = 500;


var tableSurfaceDim = [100, 2, 20];
var tablefootSurfaceDim = [80, 40, 2];
var level, _floor, _tapis, _tablefoot, _table;
function create_table(){

    //Set Level group
    level = new Physijs.BoxMesh(
        new THREE.BoxGeometry( 5, 1, .5 ),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: ptpgrey
            })
        ), 0
    );
    level.position.x = 0;
    level.position.y = 0;
    level.position.z = 0;
    level.castShadow = true;
    level.receiveShadow = true;
    level.name = 'level';


    //Add floor to level
    _floor = new Physijs.BoxMesh(
        new THREE.BoxGeometry(3000, 3000, 35),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: 0x3e3c3c
            })
        ), 0);
    _floor.rotation.x = Math.PI/2;
    _floor.position.x = 0;
    _floor.position.y = -1;
    _floor.position.z = 0;
    _floor.castShadow = true;
    _floor.receiveShadow = true;
    _floor.name = 'floor';

    scene.add(_floor);

    _tapis = new Physijs.BoxMesh(
        new THREE.BoxGeometry(planeWIDTH, planeHEIGHT, 35),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: ptpyellow
            })
        ), 0);
    _tapis.rotation.x = Math.PI/2;
    _tapis.position.x = 0;
    _tapis.position.y = 0;
    _tapis.position.z = 0;
    _tapis.castShadow = true;
    _tapis.receiveShadow = true;
    _tapis.name = 'tapis';

    scene.add(_tapis);



    //Add table foots
    _tablefoot = new Physijs.BoxMesh(
        new THREE.BoxGeometry(tablefootSurfaceDim[0], tablefootSurfaceDim[1], tablefootSurfaceDim[2]),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: cblue
            })
        ), 0);
    _tablefoot.position.x = 0;
    _tablefoot.position.y = tablefootSurfaceDim[1]-2;
    _tablefoot.position.z = -90;

    _tablefoot.castShadow = true;
    _tablefoot.receiveShadow = true;

    level.add(_tablefoot);


    _tablefoot = new Physijs.BoxMesh(
        new THREE.BoxGeometry(tablefootSurfaceDim[0], tablefootSurfaceDim[1], tablefootSurfaceDim[2]),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: cgreen
            })
        ), 0);
    _tablefoot.position.x = 0;
    _tablefoot.position.y = tablefootSurfaceDim[1];
    _tablefoot.position.z = 90;
    _tablefoot.castShadow = true;
    _tablefoot.receiveShadow = true;

    level.add(_tablefoot);

    //Add table

    _table = new Physijs.BoxMesh(
        new THREE.BoxGeometry(tableSurfaceDim[0], tableSurfaceDim[1], tableSurfaceDim[2]),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: 0xffffff
            })
        ), 0);
    _table.position.x = 0;
    _table.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2 ;
    _table.position.z = -90;
    _table.castShadow = true;
    _table.receiveShadow = true;
    level.add(_table);

    _table = new Physijs.BoxMesh(
        new THREE.BoxGeometry(tableSurfaceDim[0]+100, tableSurfaceDim[1], tableSurfaceDim[2]),
        Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
                color: 0xffffff
            })
        ), 0);
    _table.position.x = 0;
    _table.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2 ;
    _table.position.z = 90;
    _table.castShadow = true;
    _table.receiveShadow = true;
    level.add(_table);

    scene.add(level);




    // SKYDOME

    var vertexShader = document.getElementById( 'vertexShader' ).textContent;
    var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
    var uniforms = {
        topColor: 	 { type: "c", value: new THREE.Color( 0x4e4c4c ) },
        bottomColor: { type: "c", value: new THREE.Color( 0x3e3c3c ) },
        offset:		 { type: "f", value: 10 },
        exponent:	 { type: "f", value: 0.6 }
    }
    uniforms.topColor.value.copy( hemiLight.color );

    scene.fog.color.copy( uniforms.bottomColor.value );

    var skyGeo = new THREE.SphereGeometry( 1000, 64, 15 );
    var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

    var sky = new THREE.Mesh( skyGeo, skyMat );
    scene.add( sky );
}




// AXIS
function buildAxes( length ) {
    var axes = new THREE.Object3D();
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
    return axes;
}

function buildAxis( src, dst, colorHex, dashed ) {
    var geom = new THREE.Geometry(),
        mat;

    if(dashed) {
        mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
    } else {
        mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
    }

    geom.vertices.push( src.clone() );
    geom.vertices.push( dst.clone() );
    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

    var axis = new THREE.Line( geom, mat, THREE.LinePieces );

    return axis;

};var frontLight	= new THREE.DirectionalLight(0xffffff, 0.7);

var backLight	= new THREE.DirectionalLight(0xffffff, 0.7);

var ambientLight = new THREE.AmbientLight( 0x000000 );

var rightLight	= new THREE.DirectionalLight(0xfefefe, 0.4);

var leftLight	= new THREE.DirectionalLight(0xfefefe, 0.3);

var pointLight = new THREE.PointLight( 0xffffff, .6 );

function create_lights(){
    frontLight.castShadow = true;
    frontLight.shadowDarkness = .1;
    frontLight.shadowBias = -.0001;
    frontLight.shadowCameraNear = 1;
    frontLight.shadowMapWidth = 2048;
    frontLight.shadowMapHeight = 2048;
    frontLight.shadowCameraLeft = planeWIDTH/2;
    frontLight.shadowCameraTop = - planeHEIGHT/2;
    frontLight.shadowCameraRight = - planeWIDTH/2;
    frontLight.shadowCameraBottom = planeHEIGHT/2;


    frontLight.position.set(0, 100, 80);

    scene.add( frontLight );


    backLight.castShadow = true;
    backLight.shadowDarkness = .1;
    backLight.shadowBias = -.0001;
    backLight.shadowCameraNear = 1;
    backLight.shadowMapWidth = 2048;
    backLight.shadowMapHeight = 2048;
    backLight.shadowCameraLeft = planeWIDTH/2;
    backLight.shadowCameraTop = - planeHEIGHT/2;
    backLight.shadowCameraRight = - planeWIDTH/2;
    backLight.shadowCameraBottom = planeHEIGHT/2;


    backLight.position.set(0, 100, -80);

    scene.add( backLight );



    rightLight.castShadow = true;
    rightLight.shadowDarkness = .05;
    rightLight.shadowBias = -.0001;
    rightLight.shadowCameraNear = 1;
    rightLight.shadowMapWidth = 2048;
    rightLight.shadowMapHeight = 2048;
    rightLight.shadowCameraLeft = planeWIDTH/2;
    rightLight.shadowCameraTop = - planeHEIGHT/2;
    rightLight.shadowCameraRight = - planeWIDTH/2;
    rightLight.shadowCameraBottom = planeHEIGHT/2;


    rightLight.position.set(80, 40, 30);

//    scene.add( rightLight );



    leftLight.castShadow = true;
    leftLight.shadowDarkness = .05;
    leftLight.shadowBias = -.0001;
    leftLight.shadowCameraNear = 1;
    leftLight.shadowMapWidth = 2048;
    leftLight.shadowMapHeight = 2048;
    leftLight.shadowCameraLeft = planeWIDTH/2;
    leftLight.shadowCameraTop = - planeHEIGHT/2;
    leftLight.shadowCameraRight = - planeWIDTH/2;
    leftLight.shadowCameraBottom = planeHEIGHT/2;


    leftLight.position.set(-100, 70, -10);

//    scene.add( leftLight );
//
//
//    // LIGHTS
    scene.add( ambientLight );
//
//
//
//    var directionalLight = new THREE.DirectionalLight(/*Math.random() * 0xffffff*/0xeeeeee );
//    directionalLight.position.set( .2, -1, .2 );
//    directionalLight.position.normalize();
//    scene.add( directionalLight );
//
    scene.add( pointLight );

// LIGHTS


    hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.8 );
    hemiLight.color.setHSL( 0.7, 0.7, 0.9 );
    hemiLight.groundColor.setHSL( 0.5,0.5,0.5 );
    hemiLight.position.set( 0, 300, 0 );
    scene.add( hemiLight );

//    var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
//    dirLight.color.setHSL( 0.1, 1, 0.95 );
//    dirLight.position.set( -1, 90, 1 );
//    dirLight.position.multiplyScalar( 50 );
//    scene.add( dirLight );
//
//    dirLight.castShadow = true;
//
//    dirLight.shadowMapWidth = 2048;
//    dirLight.shadowMapHeight = 2048;
//
//    var d = planeHEIGHT/2;
//
//    dirLight.shadowCameraLeft = -d;
//    dirLight.shadowCameraRight = d;
//    dirLight.shadowCameraTop = d;
//    dirLight.shadowCameraBottom = -d;
//
//    dirLight.shadowCameraFar = 3500;
//    dirLight.shadowCameraNear = 1;
//    dirLight.shadowBias = -0.0001;
//    dirLight.shadowDarkness = 0.35;




}


var light1, light2, light3, light4, light5,light6,light7,light8,light9,light10,light11,light12;
function addFloatingLights(){
    var sphere = new THREE.SphereGeometry( 0.5, 16, 8 );

    light1 = new THREE.PointLight( 0xff0040, 2, 50 );
    light1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
    scene.add( light1 );

    light2 = new THREE.PointLight( 0x0040ff, 2, 50 );
    light2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
    scene.add( light2 );

    light3 = new THREE.PointLight( 0x80ff80, 2, 50 );
    light3.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x80ff80 } ) ) );
    scene.add( light3 );

    light4 = new THREE.PointLight( 0xffaa00, 2, 50 );
    light4.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
    scene.add( light4 );

    light5 = new THREE.PointLight( 0xff0040, 2, 50 );
    light5.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
    scene.add( light5 );

    light6 = new THREE.PointLight( 0x0040ff, 2, 50 );
    light6.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
    scene.add( light6 );

    light7 = new THREE.PointLight( 0x80ff80, 2, 50 );
    light7.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x80ff80 } ) ) );
    scene.add( light7 );

    light8 = new THREE.PointLight( 0xffaa00, 2, 50 );
    light8.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
    scene.add( light8 );

    light9 = new THREE.PointLight( 0xff0040, 2, 50 );
    light9.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
    scene.add( light9 );

    light10 = new THREE.PointLight( 0x0040ff, 2, 50 );
    light10.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
    scene.add( light10 );

    light11 = new THREE.PointLight( 0x80ff80, 2, 50 );
    light11.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x80ff80 } ) ) );
    scene.add( light11 );

    light12 = new THREE.PointLight( 0xffaa00, 2, 50 );
    light12.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
    scene.add( light12 );
}

function animateFloatingLights(time){
    light1.position.x = Math.sin( time * 0.7 ) * 50;
    light1.position.y = Math.cos( time * 0.5 ) * 50 + 100;
    light1.position.z = Math.cos( time * 0.3 ) * 50;

    light2.position.x = Math.cos( time * 0.3 ) * 50;
    light2.position.y = Math.sin( time * 0.5 ) * 50 + 100;
    light2.position.z = Math.sin( time * 0.7 ) * 50;

    light3.position.x = Math.sin( time * 0.7 ) * 50;
    light3.position.y = Math.cos( time * 0.3 ) * 50 + 100;
    light3.position.z = Math.sin( time * 0.5 ) * 50;

    light4.position.x = Math.sin( time * 0.3 ) * 50;
    light4.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light4.position.z = Math.sin( time * 0.5 ) * 50;

    light5.position.x = Math.sin( time * 0.3 ) * 50;
    light5.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light5.position.z = Math.sin( time * 0.5 ) * 50;

    light6.position.x = Math.sin( time * 0.3 ) * 50;
    light6.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light6.position.z = Math.sin( time * 0.5 ) * 50;

    light7.position.x = Math.sin( time * 0.3 ) * 50;
    light7.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light7.position.z = Math.sin( time * 0.5 ) * 50;

    light8.position.x = Math.sin( time * 0.3 ) * 50;
    light8.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light8.position.z = Math.sin( time * 0.5 ) * 50;

    light9.position.x = Math.sin( time * 0.3 ) * 50;
    light9.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light9.position.z = Math.sin( time * 0.5 ) * 50;

    light10.position.x = Math.sin( time * 0.3 ) * 50;
    light10.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light10.position.z = Math.sin( time * 0.5 ) * 50;

    light11.position.x = Math.sin( time * 0.3 ) * 50;
    light11.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light11.position.z = Math.sin( time * 0.5 ) * 50;

    light12.position.x = Math.sin( time * 0.3 ) * 50;
    light12.position.y = Math.cos( time * 0.7 ) * 50 + 100;
    light12.position.z = Math.sin( time * 0.5 ) * 50;

};

var Player = {
    score : 0,
    launched : 0,
    isPlaying : true,
    totalLaunched : 0,
    lives : 0,
    drunked : 0,

    initialize : function(){

        Player.lives = Party.lives;


        bottle_geo.buffersNeedUpdate = true;
        bottle_geo.uvsNeedUpdate = true;



        this.bottle = new Physijs.CylinderMesh(
            bottle_geo,
            bottle_mat,
            320, {friction : 0.1, restitution : 0.1}
        );
        this.bottle.scale.set(10,10,10);

        this.bottle.castShadow = true;
        this.bottle.receiveShadow = true;
        this.bottle.name = 'plBottle';

        Player.place({x:0, z:92});
        Player.generateBottle();
    },
    place : function(axis){
        this.bottle.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2+18;
        this.bottle.position.x = axis.x;
        this.bottle.position.z = axis.z;
    },
    generateBottle : function(){
        scene.add(Player.bottle);

//        this.bottle.material.map = texture;


        Player.generateCaps();
    },
    generateCaps : function(){


        var caps_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial(mat_caps.materials)
        );
        caps_material.side = 2;

        var maxAnisotropy = renderer.getMaxAnisotropy();
        mat_caps.anisotropy = 1;

        caps_material.color.setHex( cyellow );


        this.bottlecaps = new Physijs.CylinderMesh(geo_caps, caps_material, 0.3);
        this.bottlecaps.castShadow = true;
        this.bottlecaps.receiveShadow = true;

        this.bottlecaps.scale.set(capModelscale,capModelscale,capModelscale);
        this.bottlecaps.rotation.x = Math.PI;

        this.bottlecaps.position.y = Player.bottle.position.y + 19;
        this.bottlecaps.position.x = Player.bottle.position.x;
        this.bottlecaps.position.z = Player.bottle.position.z;

        this.bottlecaps.name = 'plCap';
        this.bottlecaps.collided = false;
        scene.add(Player.bottlecaps);
    }

}

var perfectShoot = [
    {
        y : 140,
        x  : -2,
        pwr : 30
    },
    {
        y : 100,
        x  : -1,
        pwr : 80
    },
    {
        y : 130,
        x  : 2,
        pwr : 35
    },
    {
        y : 180,
        x  : -2,
        pwr : 21
    }
];


var Viensla = {
    score : 0,
    launched : 0,
    totalLaunched : 0,
    isPerfect : false,
    imprecision : 5,
    isPlaying : false,
    lives : 0,
    initialize : function(){

        Player.lives = Party.lives;

        var bottle_material = Physijs.createMaterial(
            new THREE.MeshPhongMaterial( {  color: cgreen, specular: 0x666666, ambient: 0x000000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.8, transparent: true, side:2 } )
        );

        this.bottle = new Physijs.CylinderMesh(
            bottle_geo,
            bottle_mat,
            320, {friction : 0.1, restitution : 0.1}
        );
        this.bottle.scale.set(10,10,10);

        this.bottle.castShadow = true;
        this.bottle.receiveShadow = true;

        this.bottle.name = 'vlBottle';

        Viensla.place({x:0, z:-92});
        Viensla.generateBottle();

    },
    place : function(axis){
        this.bottle.position.y = tablefootSurfaceDim[1] +tablefootSurfaceDim[1]/2+18;
        this.bottle.position.x = axis.x;
        this.bottle.position.z = axis.z;
    },
    generateBottle : function(){
        scene.add(Viensla.bottle);
        Viensla.generateCaps();
    },
    generateCaps : function(){

        var caps_material = Physijs.createMaterial(
            new THREE.MeshLambertMaterial(mat_caps.materials)
        );
        caps_material.side = 2;

        caps_material.color.setHex( cgreen );

        this.bottlecaps = new Physijs.CylinderMesh(geo_caps, caps_material,  0.3);
        this.bottlecaps.castShadow = true;
        this.bottlecaps.receiveShadow = true;

        this.bottlecaps.scale.set(capModelscale,capModelscale,capModelscale);
        this.bottlecaps.rotation.x = Math.PI;

        this.bottlecaps.position.y = Viensla.bottle.position.y + 19;
        this.bottlecaps.position.x = Viensla.bottle.position.x;
        this.bottlecaps.position.z = Viensla.bottle.position.z;

        this.bottlecaps.name = 'vlCap';
        this.bottlecaps.collided = false;

        scene.add(Viensla.bottlecaps);
    },
    launchCaps : function(){
        Viensla.isPlaying = true;

        var  launchVector = new THREE.Vector3,
            _vector = new THREE.Vector3,
            _angVector = new THREE.Vector3,
            _posVector = new THREE.Vector3,
            randomY = Math.random()*20 + 80,
            randomX = Math.random()*10 - 5,
            shot = Math.round(Math.random()*3);


        shot = perfectShoot[shot];

        globalDirection = -1;

        power = Math.round(shot.pwr +  (Math.random()-0.5) * Viensla.imprecision);

        randomY = Math.round(shot.y +  (Math.random()-0.5) * Viensla.imprecision);

        randomX = Math.round(shot.x +  (Math.random()-0.5) * Viensla.imprecision);


        if(Viensla.isPerfect){
            var alea = Math.round(Math.random()*3);
            randomY = perfectShoot[alea].y;
            randomX  = perfectShoot[alea].x;
            power = perfectShoot[alea].pwr;
        }

        Player.isPlaying = false;

        _posVector.set(randomX,randomY, playerDistance*globalDirection);

        create_caps('vl');

        playedCaps.position.copy(_posVector);

        playedCaps.__dirtyPosition = true;
        playedCaps.floating = false;

        _vector.set( 1, 1, 1 );
        _angVector.set( Math.random()*10, Math.random()*10, Math.random()*20);
        playedCaps.setAngularFactor( _vector );

        playedCaps.setLinearFactor( _vector );
        launchVector.set(1,-3, - power * strengh * globalDirection);
        playedCaps.setLinearVelocity( launchVector );
        playedCaps.setAngularVelocity( _angVector );

        playedCaps = null;

        Viensla.launched++;
        Viensla.totalLaunched++;

    }


}







document.addEventListener(
    'keydown',
    function( ev ) {
        console.log(ev.keyCode);
        switch( ev.keyCode ) {
            case 37:
                // Left


                break;

            case 39:
                // Right

                break;

            case 38:
                // Up

                break;

            case 40:
//                Viensla.launchCaps();
                break;

            case 32:
                // space
//                create_caps();
                break;

            case 67:
//                lookatobj = ball;
                break;

            case 86:
                console.log('bottlecaps vl');
                lookatobj = BottleViensla.bottle;
                break;

            case 66:
                lookatobj = scene;
                break;

            case 65 :
                if(axes.presence){
                    axes.traverse( function ( object ) { object.visible = false; } );
                    axes.presence = false;
                }else{
                    axes.traverse( function ( object ) { object.visible = true; } );
                    axes.presence = true;
                }
            break;

            case 13:
                change_camera();
                break;
        }
    }
);
;var Sounds;

(function ($){
    var path = 'assets/sounds/';
    Sounds = {
        simpletap1 : new Audio(path+"choc_simple_1.mp3"),
        simpletap2 : new Audio(path+"choc_simple_2.mp3"),
        simpletap3 : new Audio(path+"choc_simple_3.mp3"),
        clink : new Audio(path+"clink.mp3"),
        capcap : new Audio(path+"capcap.mp3"),
        pschit1 : new Audio(path+"pschit_1.mp3"),
        pschit2 : new Audio(path+"pschit_2.mp3"),

        mute : true
    }
})(jQuery);;

THREE.ShaderTypes = {

    'phongDiffuse' : {

        uniforms: {

            "uDirLightPos":	{ type: "v3", value: new THREE.Vector3() },
            "uDirLightColor": { type: "c", value: new THREE.Color( 0xffffff ) },

            "uMaterialColor":  { type: "c", value: new THREE.Color( 0xffffff ) },

            uKd: {
                type: "f",
                value: 0.7
            },
            uBorder: {
                type: "f",
                value: 0.4
            }
        },

        vertexShader: [

            "varying vec3 vNormal;",
            "varying vec3 vViewPosition;",

            "void main() {",

            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "vNormal = normalize( normalMatrix * normal );",
            "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "vViewPosition = -mvPosition.xyz;",

            "}"

        ].join("\n"),

        fragmentShader: [

            "uniform vec3 uMaterialColor;",

            "uniform vec3 uDirLightPos;",
            "uniform vec3 uDirLightColor;",

            "uniform float uKd;",
            "uniform float uBorder;",

            "varying vec3 vNormal;",
            "varying vec3 vViewPosition;",

            "void main() {",

            // compute direction to light
            "vec4 lDirection = viewMatrix * vec4( uDirLightPos, 0.0 );",
            "vec3 lVector = normalize( lDirection.xyz );",

            // diffuse: N * L. Normal must be normalized, since it's interpolated.
            "vec3 normal = normalize( vNormal );",
            //was: "float diffuse = max( dot( normal, lVector ), 0.0);",
            // solution
            "float diffuse = dot( normal, lVector );",
            "if ( diffuse > 0.6 ) { diffuse = 1.0; }",
            "else if ( diffuse > -0.2 ) { diffuse = 0.7; }",
            "else { diffuse = 0.3; }",

            "gl_FragColor = vec4( uKd * uMaterialColor * uDirLightColor * diffuse, 1.0 );",

            "}"

        ].join("\n")

    }

};

var materialColor = new THREE.Color();
materialColor.setHex( 0xffffff );
var phongMaterial = createShaderMaterial("phongDiffuse", rightLight);
phongMaterial.uniforms.uMaterialColor.value.copy(materialColor);
phongMaterial.side = THREE.DoubleSide;

function createShaderMaterial(id, light) {

    var shader = THREE.ShaderTypes[id];

    var u = THREE.UniformsUtils.clone(shader.uniforms);

    var vs = shader.vertexShader;
    var fs = shader.fragmentShader;

    var material = new THREE.ShaderMaterial({ uniforms: u, vertexShader: vs, fragmentShader: fs });

    material.uniforms.uDirLightPos.value = light.position;
    material.uniforms.uDirLightColor.value = light.color;

    return material;

}
